# Dynamic Substantive Representation

```{r setup, include=FALSE}
options(tinytex.verbose = TRUE)

knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  dpi = 300,
  fig.width=7
)

if (!require(pacman))
  install.packages("pacman")
library(pacman)

p_install(janitor, force = FALSE)

p_load(
  # analysis
  brms,
  
  # presentation
  gridExtra,
  modelsummary,
  dotwhisker,
  ggthemes,
  latex2exp,
  RColorBrewer,
  colorRamps,
  directlabels,
  patchwork,
  
  # data wrangling
  broom,
  countrycode,
  DCPOtools,
  glue,
  here,
  imputeTS,
  janitor,
  readxl,
  rsdmx,
  tidyverse,
  wbstats)

interplot2 <- function (m, var1, var2, plot = TRUE, steps = NULL, ci = 0.95, 
                        adjCI = FALSE, hist = FALSE, var2_dt = NA, predPro = FALSE, 
                        var2_vals = NULL, point = FALSE, sims = 5000, xmin = NA, 
                        xmax = NA, ercolor = NA, esize = 0.5, ralpha = 0.5, rfill = "grey70", 
                        stats_cp = "none", txt_caption = NULL, facet_labs = NULL, 
                        ...) {
  m.class <- class(m)
  if (m.class == "list") {
    m.sims <- m %>% 
      map_df(~ arm::sim(.x, sims/100) %>% 
               pluck("fixef") %>% 
               as_tibble())
    m <- m[[1]]
  } else m.sims <- arm::sim(m, sims) %>% 
      pluck("fixef") %>% 
      as_tibble()
  factor_v1 <- factor_v2 <- FALSE
  if (is.factor(eval(parse(text = paste0("m@frame$", var1)))) & 
      is.factor(eval(parse(text = paste0("m@frame$", var2))))) 
    stop("The function does not support interactions between two factors.")
  if (is.factor(eval(parse(text = paste0("m@frame$", var1))))) {
    var1_bk <- var1
    var1 <- paste0(var1, levels(eval(parse(text = paste0("m@frame$", 
                                                         var1)))))
    factor_v1 <- TRUE
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2, ":", var1)[-1])
    for (i in seq(var12)) {
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        var12[i] <- paste0(var1, ":", var2)[-1][i]
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    }
  } else if (is.factor(eval(parse(text = paste0("m@frame$", 
                                                var2))))) {
    var2_bk <- var2
    var2 <- paste0(var2, levels(eval(parse(text = paste0("m@frame$", 
                                                         var2)))))
    factor_v2 <- TRUE
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2, ":", var1)[-1])
    for (i in seq(var12)) {
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        var12[i] <- paste0(var1, ":", var2)[-1][i]
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    }
  } else {
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2, ":", var1))
    for (i in seq(var12)) {
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        var12[i] <- paste0(var1, ":", var2)[i]
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    }
  }
  if (factor_v2) {
    xmin <- 0
    xmax <- 1
    steps <- 2
  } else {
    if (is.na(xmin)) 
      xmin <- min(m@frame[var2], na.rm = T)
    if (is.na(xmax)) 
      xmax <- max(m@frame[var2], na.rm = T)
    if (is.null(steps)) {
      steps <- eval(parse(text = paste0("length(unique(na.omit(m@frame$", 
                                        var2, ")))")))
    }
    if (steps > 100) 
      steps <- 100
  }
  coef <- data.frame(fake = seq(xmin, xmax, length.out = steps), 
                     coef1 = NA, ub = NA, lb = NA)
  coef_df <- data.frame(fake = numeric(0), coef1 = numeric(0), 
                        ub = numeric(0), lb = numeric(0), model = character(0))
  if (factor_v1) {
    if (predPro == TRUE) 
      stop("The current version does not support estimating predicted probabilities for factor base terms.")
    for (j in 1:(length(levels(eval(parse(text = paste0("m@frame$", 
                                                        var1_bk))))) - 1)) {
      for (i in 1:steps) {
        coef$coef1[i] <- mean(first(m.sims[, match(var1[j + 
                                                          1], unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                      m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]))
        coef$ub[i] <- quantile(first(m.sims[, match(var1[j + 
                                                           1], unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               (1 - ci)/2)
        coef$lb[i] <- quantile(first(m.sims[, match(var1[j + 
                                                           1], unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               1 - (1 - ci)/2)
      }
      if (plot == TRUE) {
        coef$value <- var1[j + 1]
        coef_df <- rbind(coef_df, coef)
        if (hist == TRUE) {
          if (is.na(var2_dt)) {
            var2_dt <- eval(parse(text = paste0("m@frame$", 
                                                var2)))
          }
          else {
            var2_dt <- var2_dt
          }
        }
      }
      else {
        names(coef) <- c(var2, "coef", "ub", "lb")
        return(coef)
      }
    }
    if (is.null(facet_labs)) 
      facet_labs <- unique(coef_df$value)
    coef_df$value <- factor(coef_df$value, labels = facet_labs)
    interplot:::interplot.plot(m = coef_df, hist = hist, steps = steps, 
                               var2_dt = var2_dt, point = point, ercolor = ercolor, 
                               esize = esize, ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                               txt_caption = NULL, ...) + facet_grid(. ~ value)
  } else if (factor_v2) {
    if (predPro == TRUE) 
      stop("The current version does not support estimating predicted probabilities for factor base terms.")
    for (j in 1:(length(levels(eval(parse(text = paste0("m@frame$", 
                                                        var2_bk))))) - 1)) {
      for (i in 1:steps) {
        coef$coef1[i] <- mean(first(m.sims[, match(var1, 
                                                   unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                      m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]))
        coef$ub[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               (1 - ci)/2)
        coef$lb[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               1 - (1 - ci)/2)
      }
      if (plot == TRUE) {
        coef$value <- var2[j + 1]
        coef_df <- rbind(coef_df, coef)
        if (hist == TRUE) {
          if (is.na(var2_dt)) {
            var2_dt <- eval(parse(text = paste0("m@frame$", 
                                                var2)))
          }
          else {
            var2_dt <- var2_dt
          }
        }
      }
      else {
        names(coef) <- c(var2, "coef", "ub", "lb")
        return(coef)
      }
    }
    if (is.null(facet_labs)) 
      facet_labs <- unique(coef_df$value)
    coef_df$value <- factor(coef_df$value, labels = facet_labs)
    interplot:::interplot.plot(m = coef_df, steps = steps, hist = hist, 
                               var2_dt = var2_dt, point = point, ercolor = ercolor, 
                               esize = esize, ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                               txt_caption = NULL, ...) + facet_grid(. ~ value)
  } else {
    if (predPro == TRUE) {
      if (is.null(var2_vals)) 
        stop("The predicted probabilities cannot be estimated without defining 'var2_vals'.")
      df <- data.frame(m$model)
      df[[names(m@flist)]] <- NULL
      if (sum(grep("X.weights.", names(df))) != 0) 
        df <- select(df, -X.weights.)
      df_temp <- select(df, 1)
      df <- df[-1] %>% map(function(var) {
        if (is.factor(var)) {
          model.matrix(~var - 1)[, -1] %>% as.data.frame()
        }
        else {
          as.numeric(var)
        }
      })
      for (i in seq(df)) {
        if (!is.data.frame(df[[i]])) {
          namesUpdate <- c(names(df_temp), names(df)[[i]])
          df_temp <- cbind(df_temp, df[[i]])
          names(df_temp) <- namesUpdate
        }
        else {
          df_temp <- cbind(df_temp, df[[i]])
        }
      }
      df <- df_temp
      names(df)[1] <- "(Intercept)"
      df$`(Intercept)` <- 1
      if (var1 == var2) {
        names(df) <- sub("I\\.(.*)\\.2\\.", "I\\(\\1\\^2\\)", 
                         names(df))
      }
      iv_medians <- summarize_all(df, funs(median(., na.rm = TRUE)))
      fake_data <- iv_medians[rep(1:nrow(iv_medians), 
                                  each = steps * length(var2_vals)), ]
      fake_data[[var1]] <- with(df, rep(seq(min(get(var1)), 
                                            max(get(var1)), length.out = steps), steps = length(var2_vals)))
      fake_data[[var2]] <- rep(var2_vals, each = steps)
      fake_data[[var12]] <- fake_data[[var1]] * fake_data[[var2]]
      pp <- rowMeans(plogis(data.matrix(fake_data) %*% 
                              t(data.matrix(m.sims))))
      row_quantiles <- function(x, probs) {
        naValue <- NA
        storage.mode(naValue) <- storage.mode(x)
        nrow <- nrow(x)
        q <- matrix(naValue, nrow = nrow, ncol = length(probs))
        if (nrow > 0L) {
          t <- quantile(x[1L, ], probs = probs)
          colnames(q) <- names(t)
          q[1L, ] <- t
          if (nrow >= 2L) {
            for (rr in 2:nrow) {
              q[rr, ] <- quantile(x[rr, ], probs = probs)
            }
          }
        }
        else {
          t <- quantile(0, probs = probs)
          colnames(q) <- names(t)
        }
        q <- drop(q)
        q
      }
      pp_bounds <- row_quantiles(plogis(data.matrix(fake_data) %*% 
                                          t(data.matrix(m.sims))), prob = c((1 - 
                                                                               ci)/2, 1 - (1 - ci)/2))
      pp <- cbind(pp, pp_bounds)
      pp <- pp * 100
      colnames(pp) <- c("coef1", "lb", "ub")
      pp <- cbind(fake_data[, c(var1, var2)], pp)
      pp[, var2] <- as.factor(pp[, var2])
      names(pp)[1] <- "fake"
      names(pp)[2] <- "value"
      coef <- pp
    } else {
      multiplier <- ifelse(var1 == var2, 2, 1) 
      
      for (i in 1:steps) {
        coef$coef1[i] <- mean(first(m.sims[, match(var1, 
                                                   unlist(dimnames(m@pp$X)[2]))] + {multiplier * 
                                                       coef$fake[i] * m.sims[, match(var12, 
                                                                                     unlist(dimnames(m@pp$X)[2]))]}))
        coef$ub[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + multiplier * 
                                       coef$fake[i] * m.sims[, match(var12, 
                                                                     unlist(dimnames(m@pp$X)[2]))]), (1 - ci)/2)
        coef$lb[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + multiplier * 
                                       coef$fake[i] * m.sims[, match(var12, 
                                                                     unlist(dimnames(m@pp$X)[2]))]), 1 - (1 - ci)/2)
      }
    }
    multiplier <- ifelse(var1 == var2, 2, 1) 
    min_sim <- m.sims[, match(var1, unlist(dimnames(m@pp$X)[2]))] + 
      multiplier * xmin * m.sims[, match(var12, 
                                         unlist(dimnames(m@pp$X)[2]))]
    max_sim <- m.sims[, match(var1, unlist(dimnames(m@pp$X)[2]))] + 
      multiplier * xmax * m.sims[, match(var12, 
                                         unlist(dimnames(m@pp$X)[2]))]
    diff <- first(max_sim - min_sim)
    ci_diff <- c(quantile(diff, (1 - ci)/2), quantile(diff, 
                                                      1 - (1 - ci)/2))
    if (plot == TRUE) {
      if (hist == TRUE) {
        if (is.na(var2_dt)) {
          var2_dt <- eval(parse(text = paste0("m@frame$", 
                                              var2)))
        }
        else {
          var2_dt <- var2_dt
        }
      }
      interplot:::interplot.plot(m = coef, steps = steps, hist = hist, 
                                 predPro = predPro, var2_vals = var2_vals, var2_dt = var2_dt, 
                                 point = point, ercolor = ercolor, esize = esize, 
                                 ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                                 txt_caption = NULL, ...)
    } else {
      if (predPro == TRUE) {
        names(coef) <- c(var2, paste0("values_in_", 
                                      var1), "coef", "ub", "lb")
      }
      else {
        names(coef) <- c(var2, "coef", "ub", "lb")
      }
      return(coef)
    }
  }
}

interplot_b <- function (m, var1, var2, plot = TRUE, steps = NULL, ci = 0.95, 
                         adjCI = FALSE, hist = FALSE, var2_dt = NA, predPro = FALSE, 
                         var2_vals = NULL, point = FALSE, sims = 5000, xmin = NA, 
                         xmax = NA, ercolor = NA, esize = 0.5, ralpha = 0.5, rfill = "grey70", 
                         stats_cp = "none", txt_caption = NULL, facet_labs = NULL, 
                         ...) {
  
  m.sims <- brms::as_draws_df(m) %>% 
    as_tibble()
  
  if (is.na(xmin)) 
    xmin <- min(m$data[var2], na.rm = TRUE)
  if (is.na(xmax)) 
    xmax <- max(m$data[var2], na.rm = TRUE)
  if (is.null(steps)) {
    steps <- eval(parse(text = paste0("length(unique(na.omit(m$data$", 
                                      var2, ")))")))
  }
  if (steps > 100) 
    steps <- 100
  
  coef <- data.frame(fake = seq(xmin, xmax, length.out = steps), 
                     coef1 = NA, ub = NA, lb = NA)
  coef_df <- data.frame(fake = numeric(0), coef1 = numeric(0), 
                        ub = numeric(0), lb = numeric(0), model = character(0))
  
  var1a <- str_subset(names(m.sims), var1)[1]
  var2a <- str_subset(names(m.sims), var2)[1]
  ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
         var12 <- paste0(var2a, ":", var1))
  if (!var12 %in% names(m.sims))
    var12 <- paste0(var1a, ":", var2)
  if (!var12 %in% names(m.sims)) 
    stop(paste("Model does not include the interaction of", 
               var1, "and", var2, "."))
  
  multiplier <- ifelse(var1 == var2, 2, 1) 
  
  for (i in 1:steps) {
    coef$coef1[i] <- mean({m.sims[, var1a] + {multiplier * 
        coef$fake[i] * m.sims[, var12]}}[, 1])
    coef$lb[i] <- quantile({m.sims[, var1a] + {multiplier * 
        coef$fake[i] * m.sims[, var12]}}[, 1], (1 - ci)/2)
    coef$ub[i] <- quantile({m.sims[, var1a] + {multiplier * 
        coef$fake[i] * m.sims[, var12]}}[, 1], 1 - (1 - ci)/2)
  }
  
  min_sim <- {m.sims[, var1a] + {multiplier * 
      xmin * m.sims[, var12]}}[, 1]
  max_sim <- {m.sims[, var1a] + {multiplier * 
      xmax * m.sims[, var12]}}[, 1]
  diff <- first(max_sim - min_sim)
  ci_diff <- c(quantile(diff, (1 - ci)/2), quantile(diff, 
                                                    1 - (1 - ci)/2))
  if (plot == TRUE) {
    interplot:::interplot.plot(m = coef, steps = steps, hist = hist, 
                               predPro = predPro, var2_vals = var2_vals, var2_dt = var2_dt, 
                               point = point, ercolor = ercolor, esize = esize, 
                               ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                               txt_caption = NULL, ...)
  } else {
    names(coef) <- c(var2, "coef", "ub", "lb")
    return(coef)
  }
}

make_dummies <- function(df, col) {
  vals <- discard(unique(df[[col]]), is.na)
  dummies <- map(vals, function(val) {
    df %>% 
      transmute({{val}} := as.numeric(.data[[col]] == val))
  }) %>% 
    list_cbind()
  
  bind_cols(df, dummies)
}

get_coef <- function(iv, results_df = coef_data, type = "both", width = .8) {
  result_var <- results_df %>% 
    filter(.width == width) %>% 
    pull(.variable) %>% 
    str_subset(iv)
  
  if (!type=="both") {
    res <- results_df %>% 
      filter(.variable == result_var & .width == width) %>% 
      pull({{type}})
  } else {
    sc <- results_df %>% 
      filter(.variable == result_var & .width == width) %>% 
      pull(std_coef)
    
    ci <- results_df %>% 
      filter(.variable == result_var & .width == width) %>% 
      pull(ci)
    
    wdth <- enexpr(width) * 100
    
    res <- paste0(sc, " (", wdth, "% c.i.: ", ci, ")")
  }
  
  return(res)
}

by2sd <- function(var) {
  dich <- stats::na.omit(unique(var)) %>% 
    sort() %>% identical(c(0, 1))
  if (dich) 
    sd <- 1
  else 
    sd <- 2 * stats::sd(var, na.rm = TRUE)
  
  return(sd)
}

set.seed(324)
descrep_path <- here("paper", "descriptive_representation")
policy_path <- here("paper", "policy_adoption")

oecd_countries <- c("Australia", "Austria", "Belgium",
                    "Canada", "Chile", "Colombia",
                    "Costa Rica", "Czechia", "Denmark",
                    "Estonia", "Finland", "France", 
                    "Germany", "Greece", "Hungary",
                    "Iceland", "Ireland", "Israel",
                    "Italy", "Japan", "South Korea",
                    "Latvia", "Lithuania", "Luxembourg",
                    "Mexico", "Netherlands", "New Zealand",
                    "Norway", "Poland", "Portugal", 
                    "Slovakia", "Slovenia", "Spain",
                    "Sweden", "Switzerland", "Turkey", 
                    "United Kingdom", "United States")
```

<!-- @Weeks2022a [,16]: measuring substantive representation is inherently difficult because intersectionality means women aren't monolithic -->


## Substantive Representation in Policies Advancing Gender Equality in Politics

One of the most-studied policies advancing gender equality is the adoption of gender quotas for candidates running for legislative seats.
National gender quotas---that is, candidate quotas instituted by law---mandate that women constitute a specified minimum share of each political party's candidates for the national legislature.
As we saw in the previous chapter, legislated national quotas have proven to be effective policies for increasing the share of women in office.

To measure the adoption and reform of quotas we again employ the data on the de facto threshold provided by the excellent QAROT database [@Hughes2019] updated with information from @IDEA2023.^[
There are other important aspects of national legislative quotas, such as whether and how they are enforced or if the position of women on an electoral list is specified [see, e.g., @Piscopo2024], but we leave these characteristics aside in this analysis.]

```{r dft_data3}

control_files <- c("qarot.rda", "des.rda", "fmi.rda", "gdppc.rda")
  
walk(control_files, \(f) 
     load(file.path(descrep_path, "data-raw", f), .GlobalEnv))

pge_summary <- rio::import(here("data",
                                "pge_summary.rda")) %>% 
  mutate(across(starts_with("p"),
                ~ .x * 100,
                .names = "{.col}"))
  
eee <- read_csv(file.path(descrep_path, "data-raw", "eee.csv"))

dft_data2 <- qarot %>% 
  filter(country %in% oecd_countries) %>% 
  full_join(pge_summary, by = join_by(country, year)) %>%
  left_join(des,
            by = c("countryname", "year")) %>%
  bind_rows(eee) %>% 
  left_join(fmi,
            by = c("country", "year")) %>% 
  group_by(country) %>% 
  mutate(countryname = country,
         iso2c = countrycode::countrycode(country, 
                                          "country.name",
                                          "iso2c",
                                          warn = FALSE),
         nq = defacto_threshold,
         pge_lag = lag(pge),
         pge_se_lag = lag(pge_se),
         fmi = if_else(country == "United States" & year < 1975, 3, fmi)) %>% 
  left_join(gdppc, by = c("country", "year")) %>% 
  mutate(gdppc = gdppc/10000) %>% 
  fill(list, .direction = "downup") %>% 
  fill(nq, women_rep) %>%
  mutate(nq_included = ifelse(!is.na(lag(pge)),
                              nq,
                              NA_real_)) %>% 
  ungroup() %>% 
  arrange(country, year) %>% 
  filter(country %in% oecd_countries) %>% 
  group_by(country) %>% 
  transmute(., 
            year,
            nq,
            nq_lag = if_else(row_number() == 1,
                             nq,
                             lag(nq)), # previous year
            nq_mean = mean(nq_lag, na.rm = TRUE),
            nq_diff = nq_lag - nq_mean,
            lnq = last(nq) + .0001*nq_mean,
            nq_included = ifelse(!is.na(pge_lag),
                                     nq,
                                     NA_real_),
            women_rep,
            women_rep_lag = lag(women_rep), # previous year
            women_rep_mean = mean(women_rep, na.rm = TRUE),
            women_rep_diff = women_rep - women_rep_mean,
            pge,
            pge_se,
            pge_lag, # previous year
            pge_se_lag, # previous year
            pge_mean = mean(pge_lag, na.rm = TRUE),
            pge_mean_se = sqrt(sum(pge_se_lag^2, na.rm = TRUE))/
              length(pge),
            pge_diff = pge_lag - pge_mean,
            pge_diff_se = sqrt(pge_se_lag^2 + pge_mean_se^2)/2,
            fmi,
            fmi_mean = mean(fmi, na.rm = TRUE),
            fmi_diff = fmi - fmi_mean,
            list,
            list_mean = mean(list, na.rm = TRUE),
            list_diff = list - list_mean,
            gdppc,
            gdppc_mean = mean(gdppc, na.rm = TRUE),
            gdppc_diff = gdppc - gdppc_mean) %>% 
  ungroup()

dft_data3 <- dft_data2 %>% 
  filter(., complete.cases(.))
```

```{r nqts, fig.cap="National Legislative Gender Quotas in the OECD", fig.height = 9, fig.width = 7.5}
#| label: fig-nqts

dft_data2 %>%
  ggplot(aes(x = year, y = nq)) +
  theme_bw() +
  theme(legend.position = "none") +
  coord_cartesian(xlim = c(1990, 2022)) +
  labs(x = NULL, y = "National Quota, De Facto Threshold") +
  geom_line(linetype = "dotted") +
  geom_line(aes(y = nq_included)) +
  facet_wrap(~reorder(country, -lnq), ncol = 6) +
  theme(axis.text.x  = element_text(size = 7,
                                    angle = 90,
                                    vjust = .45,
                                    hjust = .95),
        strip.text.x = element_text(size = 8),
        strip.background = element_rect(fill = "white", colour = "white"),
        plot.title = element_text(size=8)) +
  plot_annotation(caption = str_wrap("Note: Solid lines trace trends over the years covered in this chapter's analyses; dotted lines extend to years that were not\nincluded.  Sources: Hughes et al. (2019); International Institute for Democracy and Electoral Assistance (2023).", 80))
```

Recall that our measure of national quotas, first presented in the previous chapter, is the de facto threshold, which combines "a country's stated quota threshold and the breadth of a quota's actual reach" [@Hughes2019, 225].
@fig-nqts shows the trends in the adoption and reform of these national quotas over time.
Out of the thirty-eight countries of the OECD, four now have parity quotas, that is, half of the candidates run by each party must be women and half must be men: France, Belgium, Costa Rica, and Mexico.


### Substantive Representation in National Gender Quota Adoption

```{r nqplot, fig.cap="Public Gender Egalitarianism and National Quotas in the OECD", fig.height = 7, fig.width = 7.5}
#| label: fig-nq-plot
pge <- rio::import(here("data",
                        "pge.rda"))

nq_pge <- pge %>% 
  group_by(draw) %>% 
  group_split() %>% 
  map(. %>% 
        group_by(country) %>% 
        mutate(pge = pge*100) %>%
        ungroup() %>% 
        inner_join(dft_data3 %>% 
                     select(country, year, nq),
                   by = c("country", "year")))

nq_cor <- map(nq_pge,
              ~ with(.x,
                     cor(pge, nq,
                         use = "pairwise.complete.obs"))) %>% 
  unlist() %>% 
  mean() %>% 
  round(2) %>% 
  sprintf("%.2f", .) %>% 
  paste0("R = ", .)

nq_label <- tibble(pge_lag = 90,
                         nq = 4,
                         label = nq_cor)

nq_plot <- ggplot(dft_data3,
                  aes(x = pge_lag,
                      y = nq)) +
  geom_segment(aes(x = pge_lag-2*pge_se_lag, xend = pge_lag+2*pge_se_lag,
                   y = nq, yend = nq),
               na.rm = TRUE,
               alpha = .2) +
  geom_point(alpha = .2) +
  geom_smooth(method = 'lm', se = FALSE) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=10),
        axis.title = element_text(size=12)) +
  scale_x_continuous(limits=c(25, 100),
                     breaks=seq(25, 100, by = 25)) +
  scale_y_continuous(limits=c(0, 51)) +
  labs(x = TeX("Public Gender Egalitarianism$_{t-1}$"), y = "National Quota") +
  geom_label(data = nq_label, aes(label = label))

nq_plot
```

The bivariate relationship between the PGE scores and national legislative quotas in our data, depicted in @fig-nq-plot, is only weak.
Many countries, even those whose publics hold relatively egalitarian views on gender roles in the public sphere, have never adopted national gender quotas for legislative candidates; the dark, heavy line of observations across the bottom of the plot makes this clear.
However, to better assess whether these attitudes make quota adoption more likely, we need to take into account other potential explanations.

A first factor often considered likely to influence the adoption of national legislative quotas in elite-led accounts is the extent of descriptive representation women have already achieved.
There are conflicting arguments, however, regarding _how_ descriptive representation shapes quota adoption.
From one perspective, as more women are elected to the legislature, they will be more likely to successfully push for quotas to be adopted and reformed [see, e.g., @Krook2009, 21-22; @Piscopo2024].
An opposing view holds that more descriptive representation for women works instead to undermine the sense of urgency that underpins the adoption of gender quotas [see, e.g., @Dahlerup2005; @Hughes2015]. 
To measure descriptive representation here, we use the same data from QAROT and the @IPU2023 on the percentage of legislative seats held by women that we employed in the previous chapter (see @fig-wrts).

Two other potential influences on legislative quota adoption and reform are also familiar from our previous chapter: feminist movement strength and electoral lists.
Feminist movements are frequently argued to be important to the success of the adoption and reform of national quotas [see @Paxton2021, 196].
As before, we rely on the FMI [@Forester2022] as our measure of the strength of these movements (see Figure 4.5).
And consistent with arguments that electoral systems with at least a party-list component are more "woman-friendly" [@Rule1994, 27] and provide better opportunity structures for feminist activists, such electoral systems may make quota adoption and subsequent strengthening more likely as well [@Paxton2021, 195-196].
We again draw data on whether elections are held with a list component from the Democratic Electoral Systems Around the World dataset [@Bormann2022].

Our approach to modeling the adoption of gender quotas here is similar in several ways to the methods we employed in the previous chapter to model women's descriptive representation.
As in those analyses, we use a Bayesian multilevel model that includes varying intercepts for both space, which capture the idiosyncratic distinctiveness of each country, and time, which capture those shocks that operate on all countries in each year [see @Shor2007].
And also as in those analyses, we separate each of our time-varying predictors into its mean value for each country and the difference between its value in a given year in a country and this country mean so as to avoid confusing the former, cross-country, differences with the over-time changes that provide the best evidence of causation [see @Bell2015].
Another commonality with the models used in the last chapter is that we again incorporate the measurement uncertainty in the PGE scores into our analysis to avoid drawing conclusions that are not supported by the data [see @Tai2024].

The fact that we are now seeking to explain policy adoption---and in particular the adoption of a gender quota---does, however, require a few differences in our modeling strategy.
The standard approach to modeling policy adoption is event history analysis (EHA) of pooled time series, popularized in political science by @Berry1990.
Event history analysis, in this context, typically involves a logistic regression of a dichotomous dependent variable observed annually in each country as a series of zeros followed by a one at the time the policy of interest is adopted.
Once a country adopts the policy, it is no longer part of the 'risk set'---that is, the country is not 'at risk' of adopting the policy a second time---and observations for that country in years subsequent to adoption are then dropped from the dataset [see @Berry1990, 398].

However, the general EHA approach is flexible [see @Boehmke2009].
The first reason this flexibility is important is that, as @Piscopo2024 explains and as the stair-step pattern often evident in @fig-nqts illustrates, many countries have not simply adopted quotas requiring a specified share of the candidates each party puts forward to be women but have also raised this share, sometimes repeatedly, to reach or at least more closely approach parity.
Removing a country from the analysis after its first quota adoption, as in the standard EHA approach described above, would prevent us from analyzing the 'steady path' [see @Piscopo2024] by which quotas are sometimes reformed.
We consider the adoption of a parity quota, one that requires 50% of a party's candidates across all seats to be women, to be the quota policy that maximally advances gender equality, and so a country leaves the risk set---and so further observations of the country are excluded from the data---only after it has adopted a parity quota.

A second reason this flexibility is important is because national legislative gender quotas and reforms are not all the same, either present or absent.
Some countries---France, Belgium, Costa Rica, and Mexico---now have quotas that require parity in the number of women and men each party puts forward as candidates across all legislative seats.
Other countries have adopted quotas that, although requiring parties to nominate _some_ women candidates, do not require parties to run equal numbers of women and men.
Still other countries, many in fact, have no mandatory legislative gender quota at all.
We therefore treat the adoption or reform of a quota as a continuous rather than dichotomous variable [see @Boehmke2009, 237].

In a final modification of the standard EHA approach, we take into account the dynamic nature of quota adoption and reform.
That is, we account for how the quota in force in the present depends on any mandated share of women candiates that was in force in the past by including the lagged value of the quota as a predictor.

```{r m1_nq}
if (!file.exists(file.path(policy_path,  "data", "m1_nq_results.rda"))) {
  bf_nq <- bf(nq ~
                me(pge_diff, pge_diff_se) +
                me(pge_mean, pge_mean_se) +
                women_rep_diff +
                women_rep_mean +
                fmi_diff +
                fmi_mean +
                list_diff +
                list_mean +
                nq_lag +
                (1|c|country) + (1|t|year))
  
  m1_nq_b <- brm(formula = bf_nq,
                 data = dft_data3 %>% 
                   filter(!nq_lag==50),
                 backend = "cmdstanr",
                 control=list(adapt_delta = 0.99, 
                              max_treedepth = 15),
                 warmup = 500,
                 iter = 1000,
                 chains = 4,
                 cores = 4,
                 seed = 324)
  
  m1_nq_data <- m1_nq_b$data
  
  m1_nq_data_2sd <- m1_nq_data %>% 
    select(-nq,
           -country, -year, -ends_with("_se")) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    mutate(`.variable` = case_when(name == "pge_mean" ~ 
                                     "bsp_mepge_meanpge_mean_se",
                                   name == "pge_diff" ~
                                     "bsp_mepge_diffpge_diff_se",
                                   TRUE ~ paste0("b_", name)),
           var_names = c("Descriptive Representation, Difference",
                         "Descriptive Representation, Mean",
                         "Feminist Movement Index, Difference",
                         "Feminist Movement Index, Mean",
                         "Electoral List, Difference",
                         "Electoral List, Mean",
                         "Lagged Quota",
                         "Public Gender Egalitarianism, Difference",
                         "Public Gender Egalitarianism, Mean"),
           sd2 = ifelse(str_detect(.variable, "list_|fmi_diff|_lag"),
                        1,
                        value))
  
  coef_data0_m1_nq <- m1_nq_b %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!`.variable`=="b_Intercept") %>% 
    left_join(m1_nq_data_2sd, by = join_by(.variable))
  
  save(m1_national_quota_b, m1_nq_data_2sd, coef_data0_m1_nq, 
       file = file.path(policy_path, "data",  "m1_nq_results.rda"))
} else {
  load(file = file.path(policy_path, "data",  "m1_nq_results.rda"))
}
```

```{r m1nqplot, fig.cap="Predicting National Quotas in the OECD \\label{m1_nq_plot}", fig.height = 7, fig.width = 7.5}
ordered <- c("Public Gender Egalitarianism, Difference",
             "Public Gender Egalitarianism, Mean", 
             "Descriptive Representation, Difference",
             "Descriptive Representation, Mean",
             "Feminist Movement Index, Difference",
             "Feminist Movement Index, Mean", 
             "Electoral List, Difference",
             "Electoral List, Mean",
             "Lagged Quota") %>% 
  rev()

coef_data_m1_nq <- coef_data0_m1_nq %>% 
  mutate(std_coef = round(.value * sd2, 1),
         term = factor(var_names, levels = ordered)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m1_nq_data_2sd, ., by = join_by(.variable))

coef_data_m1_nq_total <- coef_data0_m1_nq %>% 
  group_by(.chain, .iteration, .draw) %>% 
  mutate(alpha = mean(ifelse(name=="nq_lag", .value, NA_real_),
                      na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(.variable) %>% 
  mutate(std_coef0 = round(.value * sd2, 1),
         std_coef = round(std_coef0/(1 - alpha), 1),
         term = factor(var_names, levels = ordered)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m1_nq_data_2sd, ., by = join_by(.variable))

coef_plot_m1_nq <- coef_data0_m1_nq %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered)) %>% 
  filter(!str_detect(var_names, "Lagged")) %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_light() +
  # coord_cartesian(xlim = c(-15, 15)) +
  xlab("Standardized Coefficients") +
  ylab(NULL)

lag_plot_m1_nq <- coef_data0_m1_nq %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered)) %>% 
  filter(str_detect(var_names, "Lagged")) %>% 
  mutate(term = "Lagged National Quota") %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_light() +
  theme(strip.text.x = element_blank(),
        strip.background = element_blank()) +
  xlab("Unstandardized Coefficient") +
  ylab(NULL)

coef_plot_m1_nq + lag_plot_m1_nq +
  plot_layout(ncol = 1, widths = c(1, 1), heights = c(8, 1)) +
  plot_annotation(caption = "Notes: Dots indicate posterior medians; whiskers describe 80% credible\nintervals; shading depicts the posterior probability distribution.")
```

Figure&nbsp;\ref{m1_nq_plot} presents the results.
Starting from the bottom, we see that 'exposure,' the remaining difference between a country's gender quota policy and a parity quota, has little predictive power on quota adoption and reform.
That is, countries that have yet to adopt any legislative candidate quota cannot be distinguished from those that already have a quota in their propensity to increase the share of women candidates each party is required put forward.

Moving upward, we next see the estimated coefficients for differences between electoral systems with a party list component as compared to systems that include only personalized races run by candidates within districts.
Countries in which all of the observed legislative terms were held with electoral systems with a list component enacted quota laws mandating that `r get_coef("list_mean", coef_data_m1_nq)` percentage points more candidates are women than those that have never held elections with party lists, with a posterior probability that---conditional on these data and this model---that this effect is positive of `r {{coef_data0_m1_nq %>% filter(name == "list_mean" & .value > 0) %>% nrow()}/20} %>% round()`%.
While this result is suggestive of long-run effects, we cannot rule out unobserved confounding variables correlated with these mean scores.
And the coefficient for the _difference_ in electoral lists within a country provides no evidence that adopting a party-list electoral system yields a higher quota of women candidates in the short run.
A causal interpretation of the association between electoral lists and gender quota adoption remains unsupported.

We turn then to the strength of the autonomous feminist movement.
Countries that have experienced higher mean scores on the Feminist Movement Index are estimated to be little different from those with lower mean FMI scores.
The best evidence for such an effect comes from the estimated coefficient for 
changes in the strength of the feminist movement over time.
A one-point increase in the FMI index over time within a country is estimated to yield a increase in the country's legislative quota of `r get_coef("fmi_diff", coef_data_m1_nq, type = "std_coef")` percentage points, but with an 80% confidence interval from `r get_coef("fmi_diff", coef_data_m1_nq, type = "ci")` points.
Here again, `r {{coef_data0_m1_nq %>% filter(name == "fmi_diff" & .value > 0) %>% nrow()}/20} %>% round()`% of the posterior probability for this coefficient is positive.
This is certainly suggestive evidence that when feminist movements grow stronger they are more successful in pushing for higher quotas.

As to the debate regarding whether more women in office creates more or less pressure for legislative quotas, this evidence falls heavily on the latter side.
A countries with a mean level of women's descriptive representation a standard deviation above the overall mean is estimated to have a mandated share of women candidates that is on average `r get_coef("women_rep_mean", coef_data_m1_nq) %>% str_replace_all("-", "")` points _lower_ than a country with mean women's descriptive representation a standard deviation below the overall mean.
And over time within a country, a two-standard-deviation increase in the share of women holding office at the start of the legislative term is estimated to decrease the average legislated quota at the end of the term by `r get_coef("women_rep_diff", coef_data_m1_nq) %>% str_replace_all("-", "")` points.

The top two rows of the panel display the evidence in support of the argument that public opinion shapes the extent of success in enacting parity legislative candidate gender quotas.
This evidence is strong.
A country with a mean public gender egalitarianism scores two standard deviations higher, for example New Zealand compared to Poland, is estimated to enact quotas requiring `r get_coef("pge_mean", coef_data_m1_nq)` percentage points more women candidates.
As we have been careful to note previously, cross-country estimates like this one provides some evidence of an effect---in this case, of a more egalitarian public on legislative quota adoption---over the long term, but they could also reflect other differences among countries correlated with the predictor, here public opinion, that we are unable to measure and include in our model.
That is, such estimates could be the result of omitted-variable bias.
Therefore, although suggestive of causal effects, the real work of this estimate is to isolate the consequences of changes in public gender egalitarianism over time.

This estimate, the coefficient for within-country changes in PGE over time, is shown in the top row of the figure.
A two-standard-deviations increase in this variable---equivalent to about a twelve-point change in the PGE score from the start of one legislative term to the beginning of the next---is estimated to yield a `r get_coef("pge_diff", coef_data_m1_nq, type = "std_coef")` percentage-point increase in a country's legislative candidate quota, with an 80% confidence interval from `r get_coef("pge_diff", coef_data_m1_nq, type = "ci")` points.
This is strong evidence that when the public of a country grows more gender egalitarian in its views with regard politics and the workplace, lawmakers respond by enacting higher legislative candidate quotas.
Public gender egalitarianism matters to electoral policy adoption.

As we saw in the previous chapter, when and where the public holds more gender egalitarian views, women are more successful in gaining elected office.
By including descriptive representation, the share of women legislators in office, in our model we effectively partition off that potential causal path.
In other words, the positive effect of public opinion on gender quota adoption just described does not work through the number of women in office.
Instead, these results support the argument that---at least among the rich democracies of the OECD---both men and women legislators respond to growing public demand for gender equality with policies that increase the mandated share of women candidates for legislative office.

### Public Responsiveness to National Gender Quota Adoption

```{r nqsem_results}    
if (!file.exists(file.path(policy_path, "data", "nqsem_results.rda"))) {  
  bf_pge <- bf(pge ~ 
                 nq_diff +
                 nq_mean +
                 women_rep_diff +
                 women_rep_mean +
                 fmi_diff +
                 fmi_mean +
                 list_diff +
                 list_mean +
                 gdppc_diff +
                 gdppc_mean +
                 pge_lag +
                 (1|c|country) + (1|t|year))
  
  m2_nqsem_b <- brm(formula = bf_nq + 
                      bf_pge + 
                      set_rescor(TRUE),  
                    data = dft_data3 %>% 
                      filter(!nq_lag==50),
                    backend = "cmdstanr",
                    control=list(adapt_delta = 0.99, 
                                 max_treedepth = 16),
                    warmup = 500, 
                    iter = 1000, 
                    chains = 4, 
                    cores = 4,
                    seed = 324)
  
  m2_data <- m2_nqsem_b$data
  
  m2_data_2sd <- m2_data %>% 
    select(pge_diff,
           pge_mean,
           women_rep_diff,
           women_rep_mean,
           fmi_diff,
           fmi_mean,
           list_mean,
           list_diff,
           nq_lag) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    mutate(`.variable` = case_when(name == "pge_mean" ~ 
                                     "bsp_nq_mepge_meanpge_mean_se",
                                   name == "pge_diff" ~
                                     "bsp_nq_mepge_diffpge_diff_se",
                                   TRUE ~ paste0("b_nq_", name)),
           var_names = c("Public Gender Egalitarianism, Difference",
                         "Public Gender Egalitarianism, Mean",
                         "Descriptive Representation, Difference",
                         "Descriptive Representation, Mean",
                         "Feminist Movement Index, Difference",
                         "Feminist Movement Index, Mean",
                         "Electoral List, Difference",
                         "Electoral List, Mean",
                         "Lagged National Quota"
           ),
           sd2 = ifelse(str_detect(.variable, "list_|_lag"),
                        1,
                        value),
           dv = "National Quota") %>% 
    bind_rows(m2_data %>% 
                select(nq_diff,
                       nq_mean,
                       women_rep_diff,
                       women_rep_mean,
                       fmi_diff,
                       fmi_mean,
                       list_mean,
                       list_diff,
                       gdppc_mean,
                       gdppc_diff,
                       pge_lag) %>% 
                summarize(across(everything(), by2sd)) %>% 
                pivot_longer(everything()) %>% 
                mutate(`.variable` = paste0("b_pge_", name),
                       var_names = c("National Quota, Difference",
                                     "National Quota, Mean",
                                     "Descriptive Representation, Difference",
                                     "Descriptive Representation, Mean",
                                     "Feminist Movement Index, Difference",
                                     "Feminist Movement Index, Mean",
                                     "Electoral List, Difference",
                                     "Electoral List, Mean",
                                     "GDP per Capita, Difference",
                                     "GDP per Capita, Mean",
                                     "Lagged Public Gender Egalitarianism"
                       ),
                       sd2 = ifelse(str_detect(.variable, "list_|_lag"),
                                    1,
                                    value),
                       dv = "Public Gender Egalitarianism")) %>% 
    mutate(dv = factor(dv, levels = c("National Quota",
                                      "Public Gender Egalitarianism")))
  
  coef_data0_nqsem <- m2_nqsem_b %>% 
    as_draws_df() %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!str_detect(`.variable`, "_Intercept")) %>% 
    left_join(m2_data_2sd, by = join_by(.variable))
  
  save(m2_data, m2_data_2sd, coef_data0_nqsem, 
       file = file.path(policy_path,
                        "data",
                        "nqsem_results.rda"))
} else {
  load(file = file.path(policy_path, "data", "nqsem_results.rda"))
}
```

```{r m2nqplot, fig.cap="Predicting the National Quota Adoption and Public Gender Egalitarianism in OECD Countries", fig.height = 9, fig.width = 7.5}
#| label: fig-m2-nq-plot

ordered_nqsem <- c("Public Gender Egalitarianism, Difference",
                   "Public Gender Egalitarianism, Mean", 
                   "National Quota, Difference",
                   "National Quota, Mean",
                   "Descriptive Representation, Difference",
                   "Descriptive Representation, Mean",
                   "Feminist Movement Index, Difference",
                   "Feminist Movement Index, Mean",
                   "Electoral List, Difference",
                   "Electoral List, Mean",
                   "GDP per Capita, Difference",
                   "GDP per Capita, Mean",
                   "Lagged National Quota",
                   "Lagged Public Gender Egalitarianism") %>% 
  rev()

coef_data_nqsem <- coef_data0_nqsem %>% 
  mutate(std_coef = round(.value * sd2, 2),
         term = factor(var_names, levels = ordered_nqsem)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m2_data_2sd, ., by = join_by(.variable))

coef_data_nqsem_total <- coef_data0_nqsem %>%  
  group_by(.chain, .iteration, .draw) %>% 
  mutate(alpha_wbl = mean(ifelse(name=="wbl_lag", .value, NA_real_),
                         na.rm = TRUE),
         alpha_pge = mean(ifelse(name=="pge_lag", .value, NA_real_),
                          na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(.variable) %>% 
  mutate(std_coef0 = round(.value * sd2, 1),
         std_coef = if_else(dv == "WBL Policy Index",
                            round(std_coef0/(1 - alpha_wbl), 1),
                            round(std_coef0/(1 - alpha_pge), 1)),
         term = factor(var_names, levels = ordered_nqsem)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  right_join(m2_data_2sd, by = join_by(.variable))

coef_plots_nqsem <- coef_data0_nqsem %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered_nqsem)) %>% 
  filter(!str_detect(var_names, "Lagged")) %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_grid(~ dv) +
  coord_cartesian(x = c(-2, 2)) +
  theme_light() +
  theme(strip.text.x = element_text(size = 10, color = "black"),
        strip.background = element_rect(fill = "white", colour = "white")) +
  xlab("Standardized Coefficients") +
  ylab(NULL)

lag_plots_nqsem <- coef_data0_nqsem %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered_nqsem)) %>% 
  filter(str_detect(var_names, "Lagged")) %>% 
  mutate(term = "Lagged Response Variable") %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_grid(~ dv) +
  theme_light() +
  theme(strip.text.x = element_blank(),
        strip.background = element_blank()) +
  xlab("Unstandardized Coefficients") +
  ylab(NULL) 

coef_plots_nqsem + lag_plots_nqsem +
  plot_layout(ncol = 1, widths = c(1, 1), heights = c(11, 1)) +
  plot_annotation(caption = "Notes: Dots indicate posterior medians; whiskers describe 80% credible\nintervals; shading depicts the posterior probability distribution.")
```

Discuss m2 results @fig-m2-nq-plot


## Substantive Representation in Policies Advancing Gender Equality in the Workplace

World Bank's Women, Business, and Law database [@WorldBank2024] 

```{r wbl}
if (!file.exists(file.path(policy_path,
                           "data-raw",
                           "wbl2024_v1.xlsx"))) {
  download.file("https://wbl.worldbank.org/content/dam/sites/wbl/documents/2024/WBL2024-1-0-Historical-Panel-Data.xlsx",
              file.path(policy_path,
                           "data-raw",
                           "wbl2024_v1.xlsx"))
}

if (!file.exists(file.path(policy_path, "data-raw", "wbl.rda"))) {
  control_files <- c("qarot.rda", "des.rda", "fmi.rda", "gdppc.rda")
  
  walk(control_files, \(f) 
       load(file.path(descrep_path, "data-raw", f), .GlobalEnv))
  
  wbl_data <- read_excel(file.path(policy_path,
                                   "data-raw",
                                   "wbl2024_v1.xlsx"),
                         sheet = "WBL Panel 2024") %>% 
    janitor::clean_names() %>% 
    mutate(country = countrycode(economy, "country.name", "country.name"),
           year = as.numeric(report_year),
           wbl = wbl_index) %>% 
    full_join(pge_summary, by = join_by(country, year)) %>%
    left_join(qarot,
              by = c("country" = "countryname", "year")) %>% 
    left_join(des,
              by = c("country" ="countryname", "year")) %>%
    left_join(fmi,
              by = c("country", "year")) %>% 
    group_by(country) %>% 
    mutate(countryname = country,
           iso2c = countrycode::countrycode(country, 
                                            "country.name",
                                            "iso2c",
                                            warn = FALSE),
           pge_lag = lag(pge),
           pge_se_lag = lag(pge_se),
           fmi = if_else(country == "United States" & year < 1975, 3, fmi),
           wbl_included = ifelse(!is.na(lag(pge)),
                                            wbl,
                                            NA_real_),
           wbl_lag = lag(wbl),
           national_quota = if_else(is.na(defacto_threshold), 0,
                                    defacto_threshold)) %>% 
    left_join(gdppc, by = c("country", "year")) %>% 
    mutate(gdppc = gdppc/10000) %>% 
    fill(list) %>% 
    ungroup() %>% 
    arrange(country, year) %>% 
    filter(country %in% oecd_countries)

  
  wbl_parent <- read_excel(file.path(policy_path,
                                     "data-raw",
                                     "wbl2024_v1.xlsx"),
                           sheet = "Parenthood") %>% 
    janitor::clean_names() %>% 
    mutate(country = countrycode(economy, "country.name", "country.name"),
           year = as.numeric(report_year),
           wbl_parent = parenthood_score/20) %>% 
    filter(country %in% oecd_countries) %>% 
    full_join(pge_summary, by = join_by(country, year)) %>%
    left_join(qarot,
              by = c("country" = "countryname", "year")) %>% 
    left_join(des,
              by = c("country" ="countryname", "year")) %>%
    left_join(fmi,
              by = c("country", "year")) %>% 
    group_by(country) %>% 
    mutate(countryname = country,
           iso2c = countrycode::countrycode(country, 
                                            "country.name",
                                            "iso2c",
                                            warn = FALSE),
           pge_lag = lag(pge),
           pge_se_lag = lag(pge_se),
           fmi = if_else(country == "United States" & year < 1975, 3, fmi),
           wbl_parent_included = ifelse(!is.na(lag(pge)),
                                            wbl,
                                            NA_real_),
           wbl_parent_reform = wbl_parent - lag(wbl_parent),
           national_quota = if_else(is.na(defacto_threshold), 0,
                                    defacto_threshold)) %>% 
    left_join(gdppc, by = c("country", "year")) %>% 
    mutate(gdppc = gdppc/10000) %>% 
    fill(list) %>% 
    ungroup() %>% 
    arrange(country, year)
  
  save(wbl_data, wbl_parent, file = file.path(policy_path,
                                              "data-raw",
                                              "wbl.rda"))
} else {
  load(file.path(policy_path, "data-raw", "wbl.rda"))
}
```

```{r wbltable}
#| label: tbl-wbl

read_excel("/Users/fsolt/Documents/Projects/gender_equality/paper/policy_adoption/data-raw/wbl2024_v1.xlsx",
           sheet = "WBL Panel 2024") %>% 
  names() %>% 
  `[`(8:55) %>% 
  as_tibble() %>% 
  filter(!str_detect(value, "^Length|[Dd]ays")) %>% 
  mutate(Indicator = if_else(str_detect(value, "[A-Z]{2,}"), value, NA_character_) %>% 
           str_replace("EURSHIP", "EUR-\nSHIP"),
         Laws = if_else(str_detect(value, "[A-Z][a-z]"), value, NA_character_),
         count_i = cumsum(!is.na(Indicator)),
         Indicator = if_else(!is.na(Indicator),
                             paste0(count_i, ". ", Indicator),
                             NA_character_)) %>% 
  fill(Indicator) %>% 
  group_by(Indicator) %>% 
  mutate(count_lp = row_number() - 1,
         Laws = if_else(!is.na(Laws),
                        paste0(count_lp, ". ", Laws),
                        "")) %>% 
  ungroup() %>% 
  mutate(Indicator = if_else(!Indicator==lag(Indicator) | row_number()==1,
                             Indicator,
                             ""),
         Laws = lead(Laws)) %>%
  select(Indicator, Laws) %>% 
  filter(!Laws=="") %>% 
  modelsummary::datasummary_df(title = "WBL Policy Index",
                               longtable = TRUE, 
                               output = "kableExtra",
                               notes = c("Source: Women, Business, and the Law Database v1.0 2024 (World Bank 2024).")) %>%
  kableExtra::kable_styling(font_size = 10) %>%
  kableExtra::column_spec(1, width = "10em") %>%
  kableExtra::column_spec(2, width = "20em")
```

@tbl-wbl shows all

```{r wblplot, fig.cap="The WBL Policy Index in the OECD", fig.height = 9, fig.width = 7.5}
#| label: fig-wblplot

wbl_data %>%
  group_by(country) %>%
  mutate(last_wbl = last(wbl, na_rm = TRUE)) %>% 
  ggplot(aes(x = year, y = wbl)) +
  geom_line(linetype = "dotted") +
  geom_line(aes(y = wbl_included)) +
  theme_bw() +
  theme(legend.position = "none") +
  coord_cartesian(ylim = c(40, 100)) +
  labs(x = NULL, y = "WBL Policy Index") +
  facet_wrap(~reorder(country, -last_wbl), ncol = 6) +
  theme(axis.text.x  = element_text(size = 7,
                                    angle = 90,
                                    vjust = .45,
                                    hjust = .95),
        strip.text.x = element_text(size = 8),
        strip.background = element_rect(fill = "white", colour = "white"),
        plot.title = element_text(size=8)) +
  plot_annotation(caption = str_wrap("Source: World Bank (2024).", 85))
```


### Substantive Representation in Policies Advancing Workplace Gender Equality
```{r wbl_b}
if (!file.exists(file.path(policy_path,
                           "data",
                           "wbl_results.rda"))) {
  
  wbl_data2 <- wbl_data %>% 
    filter(!is.na(wbl)) %>% 
    group_by(country) %>% 
    transmute(year,
              wbl,
              wbl_lag = lag(wbl), # previous year
              wbl_mean = mean(wbl_lag, na.rm = TRUE),
              wbl_diff = wbl_lag - wbl_mean,
              women_rep,
              women_rep_lag = lag(women_rep), # previous year
              women_rep_mean = mean(women_rep, na.rm = TRUE),
              women_rep_diff = women_rep - women_rep_mean,
              pge,
              pge_se,
              pge_lag, # previous year
              pge_se_lag, # previous year
              pge_mean = mean(pge_lag, na.rm = TRUE),
              pge_mean_se = sqrt(sum(pge_se_lag^2, na.rm = TRUE))/
                length(pge),
              pge_diff = pge_lag - pge_mean,
              pge_diff_se = sqrt(pge_se_lag^2 + pge_mean_se^2)/2,
              fmi,
              fmi_mean = mean(fmi, na.rm = TRUE),
              fmi_diff = fmi - fmi_mean,
              national_quota,
              national_quota_mean = mean(national_quota),
              national_quota_diff = national_quota - national_quota_mean,
              list,
              list_mean = mean(list, na.rm = TRUE),
              list_diff = list - list_mean,
              gdppc,
              gdppc_mean = mean(gdppc, na.rm = TRUE),
              gdppc_diff = gdppc - gdppc_mean) %>% 
    ungroup() %>% 
    filter(., complete.cases(.))
  
  bf_wbl <- bf(wbl ~ 
                 me(pge_diff, pge_diff_se) +
                 me(pge_mean, pge_mean_se) +
                 women_rep_diff +
                 women_rep_mean +
                 fmi_diff +
                 fmi_mean +
                 national_quota_diff +
                 national_quota_mean +
                 gdppc_diff +
                 gdppc_mean +
                 wbl_lag +
                 (1|c|country) + (1|t|year))

  m1_wbl_b <- brm(formula = bf_wbl,  
                  data = wbl_data2,
                  backend = "cmdstanr",
                  control=list(adapt_delta = 0.99, 
                               max_treedepth = 14),
                  warmup = 500, 
                  iter = 1000, 
                  chains = 4, 
                  cores = 4,
                  seed = 324)
  
  m1_data <- m1_wbl_b$data
  
  m1_data_2sd <- m1_data %>% 
    select(pge_diff,
           pge_mean,
           women_rep_diff,
           women_rep_mean,
           fmi_diff,
           fmi_mean,
           national_quota_mean,
           national_quota_diff,
           gdppc_mean,
           gdppc_diff,
           wbl_lag) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    mutate(`.variable` = case_when(name == "pge_mean" ~ 
                                     "bsp_mepge_meanpge_mean_se",
                                   name == "pge_diff" ~
                                     "bsp_mepge_diffpge_diff_se",
                                   TRUE ~ paste0("b_", name)),
           var_names = c("Public Gender Egalitarianism, Difference",
                         "Public Gender Egalitarianism, Mean",
                         "Descriptive Representation, Difference",
                         "Descriptive Representation, Mean",
                         "Feminist Movement Index, Difference",
                         "Feminist Movement Index, Mean",
                         "National Quota, Difference",
                         "National Quota, Mean",
                         "GDP per Capita, Difference",
                         "GDP per Capita, Mean",
                         "Lagged WBL Policy Index"),
           sd2 = ifelse(str_detect(.variable, "list_|fmi_diff|_lag"),
                        1,
                        value))
  
  coef_data0_m1 <- m1_wbl_b %>% 
    as_draws_df() %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!str_detect(`.variable`, "_Intercept")) %>% 
    left_join(m1_data_2sd, by = join_by(.variable))
  
  cy_summary_m1 <- m1_data %>%
    count(country) %>%
    pull(n) %>%
    summary()
  
  save(wbl_data2, 
       file = file.path(policy_path,
                        "data",
                        "wbl_data2.rda"))
  
  save(m1_data, m1_data_2sd, coef_data0_m1, cy_summary_m1, 
       file = file.path(policy_path,
                        "data",
                        "wbl_results.rda"))
} else {
  load(file = file.path(policy_path, "data", "wbl_data2.rda"))
  load(file = file.path(policy_path, "data", "wbl_results.rda"))
}
```

```{r m1wblplot, fig.cap="Predicting the WBL Policy Index in OECD Countries \\label{m1_wbl_plot}", fig.height = 7, fig.width = 7.5}
#| label: fig-m1-wbl-plot
ordered <- c("Public Gender Egalitarianism, Difference",
             "Public Gender Egalitarianism, Mean", 
             "Descriptive Representation, Difference",
             "Descriptive Representation, Mean",
             "Feminist Movement Index, Difference",
             "Feminist Movement Index, Mean", 
             "National Quota, Difference",
             "National Quota, Mean",
             "GDP per Capita, Difference",
             "GDP per Capita, Mean",
             "Lagged WBL Index") %>% 
  rev()

coef_data_m1 <- coef_data0_m1 %>% 
  mutate(std_coef = round(.value * sd2, 1),
         term = factor(var_names, levels = ordered)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m1_data_2sd, ., by = join_by(.variable))

coef_data_m1_total <- coef_data0_m1 %>% 
  group_by(.chain, .iteration, .draw) %>% 
  mutate(alpha = mean(ifelse(name=="women_rep_lag", .value, NA_real_),
                      na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(.variable) %>% 
  mutate(std_coef0 = round(.value * sd2, 1),
         std_coef = round(std_coef0/(1 - alpha), 1),
         term = factor(var_names, levels = ordered)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m1_data_2sd, ., by = join_by(.variable))

coef_plot_m1 <- coef_data0_m1 %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered)) %>% 
  filter(!str_detect(var_names, "Lagged")) %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_light() +
  xlab("Standardized Coefficients") +
  ylab(NULL) 

lag_plot_m1 <- coef_data0_m1 %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered)) %>% 
  filter(str_detect(var_names, "Lagged")) %>% 
  mutate(term = "Lagged Enrollment") %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_light() +
  theme(strip.text.x = element_blank(),
        strip.background = element_blank()) +
  xlab("Unstandardized Coefficient") +
  ylab(NULL)

coef_plot_m1 + lag_plot_m1 +
  plot_layout(ncol = 1, widths = c(1, 1), heights = c(7, 1)) +
  plot_annotation(caption = "Notes: Dots indicate posterior medians; whiskers describe 80% credible\nintervals; shading depicts the posterior probability distribution.")
```

Discuss m1 results @fig-m1-wbl-plot



```{r wblsem_results}    
if (!file.exists(file.path(policy_path, "data", "wblsem_results.rda"))) {  
  bf_pge <- bf(pge ~ 
                 wbl_diff +
                 wbl_mean +
                 women_rep_diff +
                 women_rep_mean +
                 fmi_diff +
                 fmi_mean +
                 national_quota_diff +
                 national_quota_mean +
                 gdppc_diff +
                 gdppc_mean +
                 pge_lag +
                 (1|c|country) + (1|t|year))

  m2_wblsem_b <- brm(formula = bf_wbl + 
                      bf_pge + 
                      set_rescor(TRUE),  
                    data = wbl_data2,
                    backend = "cmdstanr",
                    control=list(adapt_delta = 0.99, 
                                 max_treedepth = 14),
                    warmup = 500, 
                    iter = 1000, 
                    chains = 4, 
                    cores = 4,
                    seed = 324)
  
  m2_data <- m2_wblsem_b$data
  
  m2_data_2sd <- m2_data %>% 
    select(pge_diff,
           pge_mean,
           women_rep_diff,
           women_rep_mean,
           fmi_diff,
           fmi_mean,
           national_quota_mean,
           national_quota_diff,
           gdppc_mean,
           gdppc_diff,
           wbl_lag) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    mutate(`.variable` = case_when(name == "pge_mean" ~ 
                                     "bsp_wbl_mepge_meanpge_mean_se",
                                   name == "pge_diff" ~
                                     "bsp_wbl_mepge_diffpge_diff_se",
                                   TRUE ~ paste0("b_wbl_", name)),
           var_names = c("Public Gender Egalitarianism, Difference",
                         "Public Gender Egalitarianism, Mean",
                         "Descriptive Representation, Difference",
                         "Descriptive Representation, Mean",
                         "Feminist Movement Index, Difference",
                         "Feminist Movement Index, Mean",
                         "National Quota, Difference",
                         "National Quota, Mean",
                         "GDP per Capita, Difference",
                         "GDP per Capita, Mean",
                         "Lagged WBL Policy Index"
           ),
           sd2 = ifelse(str_detect(.variable, "list_|_lag"),
                        1,
                        value),
           dv = "WBL Policy Index") %>% 
    bind_rows(m2_data %>% 
                select(wbl_diff,
                       wbl_mean,
                       women_rep_diff,
                       women_rep_mean,
                       fmi_diff,
                       fmi_mean,
                       national_quota_mean,
                       national_quota_diff,
                       gdppc_mean,
                       gdppc_diff,
                       pge_lag) %>% 
                summarize(across(everything(), by2sd)) %>% 
                pivot_longer(everything()) %>% 
                mutate(`.variable` = paste0("b_pge_", name),
                       var_names = c("WBL Policy Index, Difference",
                                     "WBL Policy Index, Mean",
                                     "Descriptive Representation, Difference",
                                     "Descriptive Representation, Mean",
                                     "Feminist Movement Index, Difference",
                                     "Feminist Movement Index, Mean",
                                     "National Quota, Difference",
                                     "National Quota, Mean",
                                     "GDP per Capita, Difference",
                                     "GDP per Capita, Mean",
                                     "Lagged Public Gender Egalitarianism"
                       ),
                       sd2 = ifelse(str_detect(.variable, "list_|_lag"),
                                    1,
                                    value),
                       dv = "Public Gender Egalitarianism")) %>% 
    mutate(dv = factor(dv, levels = c("WBL Policy Index",
                                      "Public Gender Egalitarianism")))
  
  coef_data0_wblsem <- m2_wblsem_b %>% 
    as_draws_df() %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!str_detect(`.variable`, "_Intercept")) %>% 
    left_join(m2_data_2sd, by = join_by(.variable))
  
  save(m2_data, m2_data_2sd, coef_data0_wblsem, 
       file = file.path(policy_path,
                        "data",
                        "wblsem_results.rda"))
} else {
  load(file = file.path(policy_path, "data", "wblsem_results.rda"))
}
```

```{r m2wblplot, fig.cap="Predicting the WBL Policy Index and Public Gender Egalitarianism in OECD Countries", fig.height = 9, fig.width = 7.5}
#| label: fig-m2-wbl-plot

ordered_wblsem <- c("Public Gender Egalitarianism, Difference",
                    "Public Gender Egalitarianism, Mean", 
                    "WBL Policy Index, Difference",
                    "WBL Policy Index, Mean",
                    "Descriptive Representation, Difference",
                    "Descriptive Representation, Mean",
                    "Feminist Movement Index, Difference",
                    "Feminist Movement Index, Mean",
                    "National Quota, Difference",
                    "National Quota, Mean",
                    "GDP per Capita, Difference",
                    "GDP per Capita, Mean",
                    "Lagged WBL Policy Index",
                    "Lagged Public Gender Egalitarianism") %>% 
  rev()

coef_data_wblsem <- coef_data0_wblsem %>% 
  mutate(std_coef = round(.value * sd2, 2),
         term = factor(var_names, levels = ordered_wblsem)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m2_data_2sd, ., by = join_by(.variable))

coef_data_wblsem_total <- coef_data0_wblsem %>%  
  group_by(.chain, .iteration, .draw) %>% 
  mutate(alpha_wbl = mean(ifelse(name=="wbl_lag", .value, NA_real_),
                         na.rm = TRUE),
         alpha_pge = mean(ifelse(name=="pge_lag", .value, NA_real_),
                          na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(.variable) %>% 
  mutate(std_coef0 = round(.value * sd2, 1),
         std_coef = if_else(dv == "WBL Policy Index",
                            round(std_coef0/(1 - alpha_wbl), 1),
                            round(std_coef0/(1 - alpha_pge), 1)),
         term = factor(var_names, levels = ordered_wblsem)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  right_join(m2_data_2sd, by = join_by(.variable))

coef_plots_wblsem <- coef_data0_wblsem %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered_wblsem)) %>% 
  filter(!str_detect(var_names, "Lagged")) %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_grid(~ dv) +
  theme_light() +
  theme(strip.text.x = element_text(size = 10, color = "black"),
        strip.background = element_rect(fill = "white", colour = "white")) +
  xlab("Standardized Coefficients") +
  ylab(NULL)

lag_plots_wblsem <- coef_data0_wblsem %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered_wblsem)) %>% 
  filter(str_detect(var_names, "Lagged")) %>% 
  mutate(term = "Lagged Response Variable") %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_grid(~ dv) +
  theme_light() +
  theme(strip.text.x = element_blank(),
        strip.background = element_blank()) +
  xlab("Unstandardized Coefficients") +
  ylab(NULL) 

coef_plots_wblsem + lag_plots_wblsem +
  plot_layout(ncol = 1, widths = c(1, 1), heights = c(9, 1)) +
  plot_annotation(caption = "Notes: Dots indicate posterior medians; whiskers describe 80% credible\nintervals; shading depicts the posterior probability distribution.")
```

Discuss m2 results @fig-m2-wbl-plot

childcare advances equality in the workforce, the "dual-earner family"
leave for fathers advances the "dual-carer family", while leave for mothers reinforces traditional gender roles

One known shortcoming of v1.0 of the WBL index is its exclusion of the single policy most closely tied to gender equality in the workforce: childcare.
In 2024, the World Bank revised the WBL index to include childcare policy for the first time.
The WBL v2.0 dataset includes data on whether there are laws that establish public and private center-based childcare services as well as laws establishing employer-provided childcare.^[
The new version also highlights the importance of gender-based violence to gender equality in the workplace, moving (and expanding) laws combating sexual harassment from the Workplace indicator and provisions addressing domestic violence from the Marriage indicator, along with information about laws banning child marriage and criminalizing femicide, to a new Safety indicator [see @WorldBank2024a, 25-27].  As the WBL index v1.0 does include _some_ information on policies addressing gender-based violence, we leave analysis of these policies to future work.]
Unfortunately, this newly revised and expanded WBL index is currently available only for a single year, 2023.
That renders it unsuitable for our purposes for two reasons.
The cross-sectional nature of these data prevent the time-sensitive EHA and dynamic analyses that we employ to convincingly test responsiveness to public opinion across the high-income democracies of the OECD, and further the PGE data as yet extends to 2022 in only two of the thirty-eight countries in our sample.
We must look elsewhere for data on childcare.

```{r ecec_data}
if (!file.exists(file.path(policy_path, "data-raw", "ecec_data.csv"))) {
  download.file("https://web.archive.org/web/20240718100341/http://www.oecd.org/els/soc/PF3_2_Enrolment_childcare_preschool.xlsx",
                file.path(policy_path, "data-raw", "oecd_pf3_2.xlsx"))
  
  ecec_data <- read_excel(file.path(policy_path, "data-raw", "oecd_pf3_2.xlsx"),
                          sheet = "Enrolment_0-2-year-olds",
                          skip = 5) %>% 
    mutate(country = countrycode(...1, "iso3c", "country.name",
                                 warn = FALSE)) %>% 
    filter(!is.na(country)) %>% 
    pivot_longer(cols = matches("\\d{4}"),
                 names_to = "year",
                 names_transform = list(year = as.integer),
                 values_to = "ecec_enrollment",
                 values_transform = list(ecec_enrollment = as.numeric)) %>% 
    select(country, year, ecec_enrollment)
  
  write_csv(ecec_data, file.path(policy_path, "data-raw", "ecec_data.csv"))
} else {
  ecec_data <- read_csv(file.path(policy_path, "data-raw", "ecec_data.csv"),
                        col_types = "cddd")  
}

if (!file.exists(file.path(policy_path, "data-raw", "ecec_data1.rda"))) {
  control_files <- c("qarot.rda", "des.rda", "fmi.rda", "gdppc.rda")
  
  walk(control_files, \(f) 
       load(file.path(descrep_path, "data-raw", f), .GlobalEnv))
 
  pge_summary <- rio::import(here("data",
                                  "pge_summary.rda")) %>% 
    mutate(across(starts_with("p"),
                  ~ .x * 100,
                  .names = "{.col}"))
  
  ecec_data1 <- pge_summary %>% 
    filter(year >= 1999) %>% 
    select(country, year, pge, pge_se) %>% 
    full_join(ecec_data,
              by = c("country", "year")) %>%
    left_join(qarot,
              by = c("country" = "countryname", "year")) %>% 
    left_join(des,
              by = c("country" ="countryname", "year")) %>%
    left_join(fmi,
              by = c("country", "year")) %>% 
    group_by(country) %>% 
    mutate(countryname = country,
           iso2c = countrycode::countrycode(country, 
                                            "country.name",
                                            "iso2c",
                                            warn = FALSE),
           pge_lag = lag(pge),
           pge_se_lag = lag(pge_se),
           ecec_enr = zoo::na.approx(ecec_enrollment, na.rm = FALSE),
           ecec_enr_lag = lag(ecec_enr),
           fmi = if_else(country == "United States" & year < 1975, 3, fmi),
           women_rep_included = ifelse(!is.na(lag(pge)),
                                       women_rep,
                                       NA_real_),
           national_quota = if_else(is.na(defacto_threshold), 0,
                                    defacto_threshold)) %>% 
    filter(countryname %in% oecd_countries) %>%
    left_join(gdppc, by = c("country", "year")) %>% 
    mutate(gdppc = gdppc/10000) %>% 
    fill(list) %>% 
    ungroup() %>% 
    arrange(country, year)
  
  save(ecec_data1, file = file.path(policy_path, "data-raw", "ecec_data1.rda"))
} else {
  pge_summary <- rio::import(here("data",
                                  "pge_summary.rda")) %>% 
    mutate(across(starts_with("p"),
                  ~ .x * 100,
                  .names = "{.col}"))
  
  ecec_data1 <- rio::import(file.path(policy_path,
                                      "data-raw", 
                                      "ecec_data1.rda"))
}
```

```{r enrplot, fig.cap="Enrollment in Early Childhood Education and Care, Ages 0-2, in the OECD", fig.height = 9, fig.width = 7.5}
#| label: fig-enrplot

ecec_data1 %>%
  group_by(country) %>%
  mutate(last_enr = last(ecec_enrollment, na_rm = TRUE),
         enr_solo = if_else(is.na(lag(ecec_enrollment)) &
                                 is.na(lead(ecec_enrollment)) &
                                 !is.na(ecec_enrollment),
                            ecec_enrollment,
                            NA_real_)) %>% 
  ggplot(aes(x = year)) +
  geom_line(aes(y = ecec_enrollment)) +
  geom_point(aes(y = enr_solo), size = .1) +
  theme_bw() +
  theme(legend.position = "none") +
  coord_cartesian(xlim = c(1999, 2022)) +
  labs(x = NULL, y = "Enrollment") +
  facet_wrap(~reorder(country, -last_enr), ncol = 6) +
  theme(axis.text.x  = element_text(size = 7,
                                    angle = 90,
                                    vjust = .45,
                                    hjust = .95),
        strip.text.x = element_text(size = 8),
        strip.background = element_rect(fill = "white", colour = "white"),
        plot.title = element_text(size=8)) +
  plot_annotation(caption = str_wrap("Source: OECD (2024).", 85))
```

```{r ececenrplot, fig.cap="Public Gender Egalitarianism and Enrollment in Early Childhood Education and Care, Ages 0-2, in OECD Countries", fig.height = 9, fig.width = 7.5}
#| label: fig-ecec-enrplot

pge <- rio::import(here("data",
                        "pge.rda"))

ecec_pge <- pge %>% 
  group_by(draw) %>% 
  group_split() %>% 
  map(. %>% 
        group_by(country) %>% 
        mutate(pge = pge*100) %>%
        ungroup() %>% 
        inner_join(ecec_data,
                   by = c("country", "year")))

ecec_enr_cor <- map(ecec_pge,
                    ~ with(.x, cor(pge, ecec_enrollment,
                                   use = "pairwise.complete.obs"))) %>% 
  unlist() %>% 
  mean() %>% 
  round(2) %>% 
  sprintf("%.2f", .) %>% 
  paste0("R = ", .)

ecec_enr_label <- tibble(pge = 90, 
                         ecec_enrollment = 4,
                         label = ecec_enr_cor)

ecec_enr_plot <- ggplot(ecec_data1 %>% filter(!is.na(ecec_enrollment)),
                        aes(x = pge,
                            y = ecec_enrollment)) +
  geom_segment(aes(x = pge - 1.96*pge_se, xend = pge + 1.96*pge_se,
                   y = ecec_enrollment, yend = ecec_enrollment),
               na.rm = TRUE,
               alpha = .1) +
  geom_text(aes(label = iso2c), size = 2) +
  geom_smooth(method = 'lm', se = FALSE) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=10),
        axis.title = element_text(size=12)) +
  scale_x_continuous(limits=c(40, 100),
                     breaks=seq(40, 100, by = 20)) +
  labs(x = "Public Gender Egalitarianism", y = "Enrollment in Early Childhood\n Education and Care, Ages 0-2") +
  geom_label(data = ecec_enr_label, aes(label = label)) +
  plot_annotation(caption = "Notes: Whiskers describe 80% credible intervals.")
  
ecec_enr_plot
```

@fig-ecec-enrplot shows the bivariate relationship between gender egalitarianism and early childhood enrollments.
Each point represents a country-year and is labelled with the country's two-character ISO code. 
Enrollment rates in education and care for children aged zero to two are plotted vertically on the y-axis, and PGE scores are plotted horizontally on the x-axis; the horizontal whiskers trace the 80% credible intervals of the PGE scores.
The relationship between these two variables is positive and strong: the bivariate correlation, with the uncertainty in the PGE scores taken into account, is `r ecec_enr_cor %>% str_extract("\\.\\d{2}")`.
Still, a strong correlation is famously insufficient to establish causation.
A strong correlation may instead, for example, simply arise due to spuriousness; that is, egalitarian attitudes and early childhood care enrollments may both be driven by some third factor, such as levels of women's descriptive representation.
We need a more sophisticated model to draw firmer conclusions. 

First, we need to account for likely sources of spuriousness.
Levels of descriptive representation and the strength of the feminist movement are two variables that plausibly could influence both the public's gender egalitarian attitudes and the constellation of policies that shape the rate of young children's enrollment in education and care.
As described previously, we use data from QAROT and @IDEA2023 for the former and from @Forester2022 for the latter.

quota: @Weeks2022

To model enrollment in early childhood education and care, we use some now-familiar tools. 
We again use a Bayesian multilevel model that includes varying intercepts for 
each country and each year that capture any distinctive differences across space and any shocks that occur over time and so minimize bias due to heteroskedasticity or from variables omitted from the model [see @Shor2007].
We use the 'within-between specification' to separate time-varying predictors into their mean values for each country and the changes over time, with the latter providing the best evidence of causation [see @Bell2015].
And we of course incorporate the measurement uncertainty in the PGE scores into our model [see @Tai2024].
Finally, because past rates of early childcare enrollment should be expected to predict current values, we treat the process as dynamic and include the rate of enrollment in the previous year as a predictor.

```{r enr_b}
if (!file.exists(file.path(policy_path,
                           "data",
                           "enr_results.rda"))) {
  ecec_enr_data2 <- ecec_data1 %>% 
    filter(!is.na(ecec_enrollment)) %>% 
    group_by(country) %>% 
    transmute(year,
              ecec_enr,
              ecec_enr_lag, # previous year
              ecec_enr_mean = mean(ecec_enr_lag, na.rm = TRUE),
              ecec_enr_diff = ecec_enr_lag - ecec_enr_mean,
              women_rep,
              women_rep_lag = lag(women_rep), # previous year
              women_rep_mean = mean(women_rep, na.rm = TRUE),
              women_rep_diff = women_rep - women_rep_mean,
              pge,
              pge_se,
              pge_lag, # previous year
              pge_se_lag, # previous year
              pge_mean = mean(pge_lag, na.rm = TRUE),
              pge_mean_se = sqrt(sum(pge_se_lag^2, na.rm = TRUE))/
                length(pge),
              pge_diff = pge_lag - pge_mean,
              pge_diff_se = sqrt(pge_se_lag^2 + pge_mean_se^2)/2,
              fmi,
              fmi_mean = mean(fmi, na.rm = TRUE),
              fmi_diff = fmi - fmi_mean,
              national_quota,
              national_quota_mean = mean(national_quota),
              national_quota_diff = national_quota - national_quota_mean,
              list,
              list_mean = mean(list, na.rm = TRUE),
              list_diff = list - list_mean,
              gdppc,
              gdppc_mean = mean(gdppc, na.rm = TRUE),
              gdppc_diff = gdppc - gdppc_mean) %>% 
    ungroup() %>% 
    filter(., complete.cases(.))
  
  bf_enr <- bf(ecec_enr ~ 
                 me(pge_diff, pge_diff_se) +
                 me(pge_mean, pge_mean_se) +
                 women_rep_diff +
                 women_rep_mean +
                 fmi_diff +
                 fmi_mean +
                 national_quota_diff +
                 national_quota_mean +
                 gdppc_diff +
                 gdppc_mean +
                 ecec_enr_lag +
                 (1|c|country) + (1|t|year))

  m1_enr_b <- brm(formula = bf_enr,  
                  data = ecec_enr_data2,
                  backend = "cmdstanr",
                  control=list(adapt_delta = 0.99, 
                               max_treedepth = 14),
                  warmup = 500, 
                  iter = 1000, 
                  chains = 4, 
                  cores = 4,
                  seed = 324)
  
  m1_data <- m1_enr_b$data
  
  m1_data_2sd <- m1_data %>% 
    select(pge_diff,
           pge_mean,
           women_rep_diff,
           women_rep_mean,
           fmi_diff,
           fmi_mean,
           national_quota_mean,
           national_quota_diff,
           gdppc_mean,
           gdppc_diff,
           ecec_enr_lag) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    mutate(`.variable` = case_when(name == "pge_mean" ~ 
                                     "bsp_mepge_meanpge_mean_se",
                                   name == "pge_diff" ~
                                     "bsp_mepge_diffpge_diff_se",
                                   TRUE ~ paste0("b_", name)),
           var_names = c("Public Gender Egalitarianism, Difference",
                         "Public Gender Egalitarianism, Mean",
                         "Descriptive Representation, Difference",
                         "Descriptive Representation, Mean",
                         "Feminist Movement Index, Difference",
                         "Feminist Movement Index, Mean",
                         "National Quota, Difference",
                         "National Quota, Mean",
                         "GDP per Capita, Difference",
                         "GDP per Capita, Mean",
                         "Lagged Enrollment"),
           sd2 = ifelse(str_detect(.variable, "list_|fmi_diff|_lag"),
                        1,
                        value))
  
  coef_data0_m1 <- m1_enr_b %>% 
    as_draws_df() %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!str_detect(`.variable`, "_Intercept")) %>% 
    left_join(m1_data_2sd, by = join_by(.variable))
  
  cy_summary_m1 <- m1_data %>%
    count(country) %>%
    pull(n) %>%
    summary()
  
  save(ecec_enr_data2, 
       file = file.path(policy_path,
                        "data",
                        "ecec_enr_data2.rda"))
  
  save(m1_data, m1_data_2sd, coef_data0_m1, cy_summary_m1, 
       file = file.path(policy_path,
                        "data",
                        "enr_results.rda"))
} else {
  load(file = file.path(policy_path, "data", "ecec_enr_data2.rda"))
  load(file = file.path(policy_path, "data", "enr_results.rda"))
}
```

```{r m1enrplot, fig.cap="Predicting Enrollment in Early Childhood Education and Care, Ages 0-2, in OECD Countries \\label{m1_enr_plot}", fig.height = 7, fig.width = 7.5}
ordered <- c("Public Gender Egalitarianism, Difference",
             "Public Gender Egalitarianism, Mean", 
             "Descriptive Representation, Difference",
             "Descriptive Representation, Mean",
             "Feminist Movement Index, Difference",
             "Feminist Movement Index, Mean", 
             "National Quota, Difference",
             "National Quota, Mean",
             "GDP per Capita, Difference",
             "GDP per Capita, Mean",
             "Lagged Enrollment") %>% 
  rev()

coef_data_m1 <- coef_data0_m1 %>% 
  mutate(std_coef = round(.value * sd2, 1),
         term = factor(var_names, levels = ordered)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m1_data_2sd, ., by = join_by(.variable))

coef_data_m1_total <- coef_data0_m1 %>% 
  group_by(.chain, .iteration, .draw) %>% 
  mutate(alpha = mean(ifelse(name=="women_rep_lag", .value, NA_real_),
                      na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(.variable) %>% 
  mutate(std_coef0 = round(.value * sd2, 1),
         std_coef = round(std_coef0/(1 - alpha), 1),
         term = factor(var_names, levels = ordered)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m1_data_2sd, ., by = join_by(.variable))

coef_plot_m1 <- coef_data0_m1 %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered)) %>% 
  filter(!str_detect(var_names, "Lagged")) %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_light() +
  xlab("Standardized Coefficients") +
  ylab(NULL) 

lag_plot_m1 <- coef_data0_m1 %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered)) %>% 
  filter(str_detect(var_names, "Lagged")) %>% 
  mutate(term = "Lagged Enrollment") %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_light() +
  theme(strip.text.x = element_blank(),
        strip.background = element_blank()) +
  xlab("Unstandardized Coefficient") +
  ylab(NULL)

coef_plot_m1 + lag_plot_m1 +
  plot_layout(ncol = 1, widths = c(1, 1), heights = c(7, 1)) +
  plot_annotation(caption = "Notes: Dots indicate posterior medians; whiskers describe 80% credible\nintervals; shading depicts the posterior probability distribution.")
```

### Public Responsiveness to Policies Advancing Workplace Gender Equality

@Sjoberg2004 argues that institutionalized family policies, particularly the provision of early childhood education and care, promote married women's labor force participation and so reshape attitudes toward gender roles in the public sphere.
That is, because these policies "contain normative elements and expectations on the 'proper' role of men as well as women in society and in the family," they can be expected to influence the public's attitudes on gender egalitarianism in the public sphere [@Sjoberg2004, 113].


```{r enrsem_results.rda}    
if (!file.exists(file.path(policy_path, "data", "enrsem_results.rda"))) {  
  bf_pge <- bf(pge ~ 
                 ecec_enr_diff +
                 ecec_enr_mean +
                 women_rep_diff +
                 women_rep_mean +
                 fmi_diff +
                 fmi_mean +
                 national_quota_diff +
                 national_quota_mean +
                 gdppc_diff +
                 gdppc_mean +
                 pge_lag +
                 (1|c|country) + (1|t|year))

  m2_enrsem_b <- brm(formula = bf_enr + 
                      bf_pge + 
                      set_rescor(TRUE),  
                    data = ecec_enr_data2,
                    backend = "cmdstanr",
                    control=list(adapt_delta = 0.99, 
                                 max_treedepth = 14),
                    warmup = 500, 
                    iter = 1000, 
                    chains = 4, 
                    cores = 4,
                    seed = 324)
  
  m2_data <- m2_enrsem_b$data
  
  m2_data_2sd <- m2_data %>% 
    select(pge_diff,
           pge_mean,
           women_rep_diff,
           women_rep_mean,
           fmi_diff,
           fmi_mean,
           national_quota_mean,
           national_quota_diff,
           gdppc_mean,
           gdppc_diff,
           ecec_enr_lag) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    mutate(`.variable` = case_when(name == "pge_mean" ~ 
                                     "bsp_ececenr_mepge_meanpge_mean_se",
                                   name == "pge_diff" ~
                                     "bsp_ececenr_mepge_diffpge_diff_se",
                                   TRUE ~ paste0("b_ececenr_", name)),
           var_names = c("Public Gender Egalitarianism, Difference",
                         "Public Gender Egalitarianism, Mean",
                         "Descriptive Representation, Difference",
                         "Descriptive Representation, Mean",
                         "Feminist Movement Index, Difference",
                         "Feminist Movement Index, Mean",
                         "National Quota, Difference",
                         "National Quota, Mean",
                         "GDP per Capita, Difference",
                         "GDP per Capita, Mean",
                         "Lagged Enrollment"
           ),
           sd2 = ifelse(str_detect(.variable, "list_|_lag"),
                        1,
                        value),
           dv = "Enrollment") %>% 
    bind_rows(m2_data %>% 
                select(ecec_enr_diff,
                       ecec_enr_mean,
                       women_rep_diff,
                       women_rep_mean,
                       fmi_diff,
                       fmi_mean,
                       national_quota_mean,
                       national_quota_diff,
                       gdppc_mean,
                       gdppc_diff,
                       pge_lag) %>% 
                summarize(across(everything(), by2sd)) %>% 
                pivot_longer(everything()) %>% 
                mutate(`.variable` = paste0("b_pge_", name),
                       var_names = c("Enrollment, Difference",
                                     "Enrollment, Mean",
                                     "Descriptive Representation, Difference",
                                     "Descriptive Representation, Mean",
                                     "Feminist Movement Index, Difference",
                                     "Feminist Movement Index, Mean",
                                     "National Quota, Difference",
                                     "National Quota, Mean",
                                     "GDP per Capita, Difference",
                                     "GDP per Capita, Mean",
                                     "Lagged Public Gender Egalitarianism"
                       ),
                       sd2 = ifelse(str_detect(.variable, "list_|_lag"),
                                    1,
                                    value),
                       dv = "Public Gender Egalitarianism")) %>% 
    mutate(dv = factor(dv, levels = c("Enrollment",
                                      "Public Gender Egalitarianism")))
  
  coef_data0_enrsem <- m2_enrsem_b %>% 
    as_draws_df() %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!str_detect(`.variable`, "_Intercept")) %>% 
    left_join(m2_data_2sd, by = join_by(.variable))
  
  save(m2_data, m2_data_2sd, coef_data0_enrsem, 
       file = file.path(policy_path,
                        "data",
                        "enrsem_results.rda"))
} else {
  load(file = file.path(policy_path, "data", "enrsem_results.rda"))
}
```

```{r m2enrplot, fig.cap="Predicting Enrollment in Early Childhood Education and Care, Ages 0-2, in OECD Countries \\label{m2_enr_plot}", fig.height = 9, fig.width = 7.5}

ordered_enrsem <- c("Public Gender Egalitarianism, Difference",
                    "Public Gender Egalitarianism, Mean", 
                    "Enrollment, Difference",
                    "Enrollment, Mean",
                    "Descriptive Representation, Difference",
                    "Descriptive Representation, Mean",
                    "Feminist Movement Index, Difference",
                    "Feminist Movement Index, Mean",
                    "National Quota, Difference",
                    "National Quota, Mean",
                    "GDP per Capita, Difference",
                    "GDP per Capita, Mean",
                    "Lagged Enrollment",
                    "Lagged Public Gender Egalitarianism") %>% 
  rev()

coef_data_enrsem <- coef_data0_enrsem %>% 
  mutate(std_coef = round(.value * sd2, 2),
         term = factor(var_names, levels = ordered_enrsem)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m2_data_2sd, ., by = join_by(.variable))

coef_data_enrsem_total <- coef_data0_enrsem %>%  
  group_by(.chain, .iteration, .draw) %>% 
  mutate(alpha_enr = mean(ifelse(name=="ecec_enr_lag", .value, NA_real_),
                         na.rm = TRUE),
         alpha_pge = mean(ifelse(name=="pge_lag", .value, NA_real_),
                          na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(.variable) %>% 
  mutate(std_coef0 = round(.value * sd2, 1),
         std_coef = if_else(dv == "Enrollment",
                            round(std_coef0/(1 - alpha_enr), 1),
                            round(std_coef0/(1 - alpha_pge), 1)),
         term = factor(var_names, levels = ordered_enrsem)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  right_join(m2_data_2sd, by = join_by(.variable))

coef_plots_enrsem <- coef_data0_enrsem %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered_enrsem)) %>% 
  filter(!str_detect(var_names, "Lagged")) %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_grid(~ dv) +
  coord_cartesian(xlim = c(-6, 6)) +
  theme_light() +
  theme(strip.text.x = element_text(size = 10, color = "black"),
        strip.background = element_rect(fill = "white", colour = "white")) +
  xlab("Standardized Coefficients") +
  ylab(NULL)

lag_plots_enrsem <- coef_data0_enrsem %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered_enrsem)) %>% 
  filter(str_detect(var_names, "Lagged")) %>% 
  mutate(term = "Lagged Response Variable") %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = .8,
                       fill = "grey60",
                       linewidth = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_grid(~ dv) +
  theme_light() +
  theme(strip.text.x = element_blank(),
        strip.background = element_blank()) +
  xlab("Unstandardized Coefficients") +
  ylab(NULL) 

coef_plots_enrsem + lag_plots_enrsem +
  plot_layout(ncol = 1, widths = c(1, 1), heights = c(9, 1)) +
  plot_annotation(caption = "Notes: Dots indicate posterior medians; whiskers describe 80% credible\nintervals; shading depicts the posterior probability distribution.")
```

## Conclusions
