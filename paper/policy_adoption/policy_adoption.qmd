# From Public Egalitarianism to Equality: Understanding Policy Adoption

```{r setup, include=FALSE}
options(tinytex.verbose = TRUE)

knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  dpi = 300,
  fig.width=7
)

if (!require(pacman))
  install.packages("pacman")
library(pacman)

p_install(janitor, force = FALSE)

p_load(
  # analysis
  brms,
  
  # presentation
  gridExtra,
  modelsummary,
  dotwhisker,
  ggthemes,
  latex2exp,
  RColorBrewer,
  colorRamps,
  directlabels,
  patchwork,
  
  # data wrangling
  broom,
  countrycode,
  DCPOtools,
  glue,
  here,
  janitor,
  tidyverse,
  wbstats)

interplot2 <- function (m, var1, var2, plot = TRUE, steps = NULL, ci = 0.95, 
                        adjCI = FALSE, hist = FALSE, var2_dt = NA, predPro = FALSE, 
                        var2_vals = NULL, point = FALSE, sims = 5000, xmin = NA, 
                        xmax = NA, ercolor = NA, esize = 0.5, ralpha = 0.5, rfill = "grey70", 
                        stats_cp = "none", txt_caption = NULL, facet_labs = NULL, 
                        ...) {
  m.class <- class(m)
  if (m.class == "list") {
    m.sims <- m %>% 
      map_df(~ arm::sim(.x, sims/100) %>% 
               pluck("fixef") %>% 
               as_tibble())
    m <- m[[1]]
  } else m.sims <- arm::sim(m, sims) %>% 
      pluck("fixef") %>% 
      as_tibble()
  factor_v1 <- factor_v2 <- FALSE
  if (is.factor(eval(parse(text = paste0("m@frame$", var1)))) & 
      is.factor(eval(parse(text = paste0("m@frame$", var2))))) 
    stop("The function does not support interactions between two factors.")
  if (is.factor(eval(parse(text = paste0("m@frame$", var1))))) {
    var1_bk <- var1
    var1 <- paste0(var1, levels(eval(parse(text = paste0("m@frame$", 
                                                         var1)))))
    factor_v1 <- TRUE
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2, ":", var1)[-1])
    for (i in seq(var12)) {
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        var12[i] <- paste0(var1, ":", var2)[-1][i]
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    }
  } else if (is.factor(eval(parse(text = paste0("m@frame$", 
                                                var2))))) {
    var2_bk <- var2
    var2 <- paste0(var2, levels(eval(parse(text = paste0("m@frame$", 
                                                         var2)))))
    factor_v2 <- TRUE
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2, ":", var1)[-1])
    for (i in seq(var12)) {
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        var12[i] <- paste0(var1, ":", var2)[-1][i]
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    }
  } else {
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2, ":", var1))
    for (i in seq(var12)) {
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        var12[i] <- paste0(var1, ":", var2)[i]
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    }
  }
  if (factor_v2) {
    xmin <- 0
    xmax <- 1
    steps <- 2
  } else {
    if (is.na(xmin)) 
      xmin <- min(m@frame[var2], na.rm = T)
    if (is.na(xmax)) 
      xmax <- max(m@frame[var2], na.rm = T)
    if (is.null(steps)) {
      steps <- eval(parse(text = paste0("length(unique(na.omit(m@frame$", 
                                        var2, ")))")))
    }
    if (steps > 100) 
      steps <- 100
  }
  coef <- data.frame(fake = seq(xmin, xmax, length.out = steps), 
                     coef1 = NA, ub = NA, lb = NA)
  coef_df <- data.frame(fake = numeric(0), coef1 = numeric(0), 
                        ub = numeric(0), lb = numeric(0), model = character(0))
  if (factor_v1) {
    if (predPro == TRUE) 
      stop("The current version does not support estimating predicted probabilities for factor base terms.")
    for (j in 1:(length(levels(eval(parse(text = paste0("m@frame$", 
                                                        var1_bk))))) - 1)) {
      for (i in 1:steps) {
        coef$coef1[i] <- mean(first(m.sims[, match(var1[j + 
                                                          1], unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                      m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]))
        coef$ub[i] <- quantile(first(m.sims[, match(var1[j + 
                                                           1], unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               (1 - ci)/2)
        coef$lb[i] <- quantile(first(m.sims[, match(var1[j + 
                                                           1], unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               1 - (1 - ci)/2)
      }
      if (plot == TRUE) {
        coef$value <- var1[j + 1]
        coef_df <- rbind(coef_df, coef)
        if (hist == TRUE) {
          if (is.na(var2_dt)) {
            var2_dt <- eval(parse(text = paste0("m@frame$", 
                                                var2)))
          }
          else {
            var2_dt <- var2_dt
          }
        }
      }
      else {
        names(coef) <- c(var2, "coef", "ub", "lb")
        return(coef)
      }
    }
    if (is.null(facet_labs)) 
      facet_labs <- unique(coef_df$value)
    coef_df$value <- factor(coef_df$value, labels = facet_labs)
    interplot:::interplot.plot(m = coef_df, hist = hist, steps = steps, 
                               var2_dt = var2_dt, point = point, ercolor = ercolor, 
                               esize = esize, ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                               txt_caption = NULL, ...) + facet_grid(. ~ value)
  } else if (factor_v2) {
    if (predPro == TRUE) 
      stop("The current version does not support estimating predicted probabilities for factor base terms.")
    for (j in 1:(length(levels(eval(parse(text = paste0("m@frame$", 
                                                        var2_bk))))) - 1)) {
      for (i in 1:steps) {
        coef$coef1[i] <- mean(first(m.sims[, match(var1, 
                                                   unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                      m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]))
        coef$ub[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               (1 - ci)/2)
        coef$lb[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               1 - (1 - ci)/2)
      }
      if (plot == TRUE) {
        coef$value <- var2[j + 1]
        coef_df <- rbind(coef_df, coef)
        if (hist == TRUE) {
          if (is.na(var2_dt)) {
            var2_dt <- eval(parse(text = paste0("m@frame$", 
                                                var2)))
          }
          else {
            var2_dt <- var2_dt
          }
        }
      }
      else {
        names(coef) <- c(var2, "coef", "ub", "lb")
        return(coef)
      }
    }
    if (is.null(facet_labs)) 
      facet_labs <- unique(coef_df$value)
    coef_df$value <- factor(coef_df$value, labels = facet_labs)
    interplot:::interplot.plot(m = coef_df, steps = steps, hist = hist, 
                               var2_dt = var2_dt, point = point, ercolor = ercolor, 
                               esize = esize, ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                               txt_caption = NULL, ...) + facet_grid(. ~ value)
  } else {
    if (predPro == TRUE) {
      if (is.null(var2_vals)) 
        stop("The predicted probabilities cannot be estimated without defining 'var2_vals'.")
      df <- data.frame(m$model)
      df[[names(m@flist)]] <- NULL
      if (sum(grep("X.weights.", names(df))) != 0) 
        df <- select(df, -X.weights.)
      df_temp <- select(df, 1)
      df <- df[-1] %>% map(function(var) {
        if (is.factor(var)) {
          model.matrix(~var - 1)[, -1] %>% as.data.frame()
        }
        else {
          as.numeric(var)
        }
      })
      for (i in seq(df)) {
        if (!is.data.frame(df[[i]])) {
          namesUpdate <- c(names(df_temp), names(df)[[i]])
          df_temp <- cbind(df_temp, df[[i]])
          names(df_temp) <- namesUpdate
        }
        else {
          df_temp <- cbind(df_temp, df[[i]])
        }
      }
      df <- df_temp
      names(df)[1] <- "(Intercept)"
      df$`(Intercept)` <- 1
      if (var1 == var2) {
        names(df) <- sub("I\\.(.*)\\.2\\.", "I\\(\\1\\^2\\)", 
                         names(df))
      }
      iv_medians <- summarize_all(df, funs(median(., na.rm = TRUE)))
      fake_data <- iv_medians[rep(1:nrow(iv_medians), 
                                  each = steps * length(var2_vals)), ]
      fake_data[[var1]] <- with(df, rep(seq(min(get(var1)), 
                                            max(get(var1)), length.out = steps), steps = length(var2_vals)))
      fake_data[[var2]] <- rep(var2_vals, each = steps)
      fake_data[[var12]] <- fake_data[[var1]] * fake_data[[var2]]
      pp <- rowMeans(plogis(data.matrix(fake_data) %*% 
                              t(data.matrix(m.sims))))
      row_quantiles <- function(x, probs) {
        naValue <- NA
        storage.mode(naValue) <- storage.mode(x)
        nrow <- nrow(x)
        q <- matrix(naValue, nrow = nrow, ncol = length(probs))
        if (nrow > 0L) {
          t <- quantile(x[1L, ], probs = probs)
          colnames(q) <- names(t)
          q[1L, ] <- t
          if (nrow >= 2L) {
            for (rr in 2:nrow) {
              q[rr, ] <- quantile(x[rr, ], probs = probs)
            }
          }
        }
        else {
          t <- quantile(0, probs = probs)
          colnames(q) <- names(t)
        }
        q <- drop(q)
        q
      }
      pp_bounds <- row_quantiles(plogis(data.matrix(fake_data) %*% 
                                          t(data.matrix(m.sims))), prob = c((1 - 
                                                                               ci)/2, 1 - (1 - ci)/2))
      pp <- cbind(pp, pp_bounds)
      pp <- pp * 100
      colnames(pp) <- c("coef1", "lb", "ub")
      pp <- cbind(fake_data[, c(var1, var2)], pp)
      pp[, var2] <- as.factor(pp[, var2])
      names(pp)[1] <- "fake"
      names(pp)[2] <- "value"
      coef <- pp
    } else {
      multiplier <- ifelse(var1 == var2, 2, 1) 
      
      for (i in 1:steps) {
        coef$coef1[i] <- mean(first(m.sims[, match(var1, 
                                                   unlist(dimnames(m@pp$X)[2]))] + {multiplier * 
                                                       coef$fake[i] * m.sims[, match(var12, 
                                                                                     unlist(dimnames(m@pp$X)[2]))]}))
        coef$ub[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + multiplier * 
                                       coef$fake[i] * m.sims[, match(var12, 
                                                                     unlist(dimnames(m@pp$X)[2]))]), (1 - ci)/2)
        coef$lb[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + multiplier * 
                                       coef$fake[i] * m.sims[, match(var12, 
                                                                     unlist(dimnames(m@pp$X)[2]))]), 1 - (1 - ci)/2)
      }
    }
    multiplier <- ifelse(var1 == var2, 2, 1) 
    min_sim <- m.sims[, match(var1, unlist(dimnames(m@pp$X)[2]))] + 
      multiplier * xmin * m.sims[, match(var12, 
                                         unlist(dimnames(m@pp$X)[2]))]
    max_sim <- m.sims[, match(var1, unlist(dimnames(m@pp$X)[2]))] + 
      multiplier * xmax * m.sims[, match(var12, 
                                         unlist(dimnames(m@pp$X)[2]))]
    diff <- first(max_sim - min_sim)
    ci_diff <- c(quantile(diff, (1 - ci)/2), quantile(diff, 
                                                      1 - (1 - ci)/2))
    if (plot == TRUE) {
      if (hist == TRUE) {
        if (is.na(var2_dt)) {
          var2_dt <- eval(parse(text = paste0("m@frame$", 
                                              var2)))
        }
        else {
          var2_dt <- var2_dt
        }
      }
      interplot:::interplot.plot(m = coef, steps = steps, hist = hist, 
                                 predPro = predPro, var2_vals = var2_vals, var2_dt = var2_dt, 
                                 point = point, ercolor = ercolor, esize = esize, 
                                 ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                                 txt_caption = NULL, ...)
    } else {
      if (predPro == TRUE) {
        names(coef) <- c(var2, paste0("values_in_", 
                                      var1), "coef", "ub", "lb")
      }
      else {
        names(coef) <- c(var2, "coef", "ub", "lb")
      }
      return(coef)
    }
  }
}

interplot_b <- function (m, var1, var2, plot = TRUE, steps = NULL, ci = 0.95, 
                         adjCI = FALSE, hist = FALSE, var2_dt = NA, predPro = FALSE, 
                         var2_vals = NULL, point = FALSE, sims = 5000, xmin = NA, 
                         xmax = NA, ercolor = NA, esize = 0.5, ralpha = 0.5, rfill = "grey70", 
                         stats_cp = "none", txt_caption = NULL, facet_labs = NULL, 
                         ...) {
  
  m.sims <- brms::as_draws_df(m) %>% 
    as_tibble()
  
  if (is.na(xmin)) 
    xmin <- min(m$data[var2], na.rm = TRUE)
  if (is.na(xmax)) 
    xmax <- max(m$data[var2], na.rm = TRUE)
  if (is.null(steps)) {
    steps <- eval(parse(text = paste0("length(unique(na.omit(m$data$", 
                                      var2, ")))")))
  }
  if (steps > 100) 
    steps <- 100
  
  coef <- data.frame(fake = seq(xmin, xmax, length.out = steps), 
                     coef1 = NA, ub = NA, lb = NA)
  coef_df <- data.frame(fake = numeric(0), coef1 = numeric(0), 
                        ub = numeric(0), lb = numeric(0), model = character(0))
  
  var1a <- str_subset(names(m.sims), var1)[1]
  var2a <- str_subset(names(m.sims), var2)[1]
  ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
         var12 <- paste0(var2a, ":", var1))
  if (!var12 %in% names(m.sims))
    var12 <- paste0(var1a, ":", var2)
  if (!var12 %in% names(m.sims)) 
    stop(paste("Model does not include the interaction of", 
               var1, "and", var2, "."))
  
  multiplier <- ifelse(var1 == var2, 2, 1) 
  
  for (i in 1:steps) {
    coef$coef1[i] <- mean({m.sims[, var1a] + {multiplier * 
        coef$fake[i] * m.sims[, var12]}}[, 1])
    coef$lb[i] <- quantile({m.sims[, var1a] + {multiplier * 
        coef$fake[i] * m.sims[, var12]}}[, 1], (1 - ci)/2)
    coef$ub[i] <- quantile({m.sims[, var1a] + {multiplier * 
        coef$fake[i] * m.sims[, var12]}}[, 1], 1 - (1 - ci)/2)
  }
  
  min_sim <- {m.sims[, var1a] + {multiplier * 
      xmin * m.sims[, var12]}}[, 1]
  max_sim <- {m.sims[, var1a] + {multiplier * 
      xmax * m.sims[, var12]}}[, 1]
  diff <- first(max_sim - min_sim)
  ci_diff <- c(quantile(diff, (1 - ci)/2), quantile(diff, 
                                                    1 - (1 - ci)/2))
  if (plot == TRUE) {
    interplot:::interplot.plot(m = coef, steps = steps, hist = hist, 
                               predPro = predPro, var2_vals = var2_vals, var2_dt = var2_dt, 
                               point = point, ercolor = ercolor, esize = esize, 
                               ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                               txt_caption = NULL, ...)
  } else {
    names(coef) <- c(var2, "coef", "ub", "lb")
    return(coef)
  }
}

make_dummies <- function(df, col) {
  vals <- discard(unique(df[[col]]), is.na)
  dummies <- map(vals, function(val) {
    df %>% 
      transmute({{val}} := as.numeric(.data[[col]] == val))
  }) %>% 
    list_cbind()
  
  bind_cols(df, dummies)
}

get_coef <- function(iv, results_df = coef_data, type = "both", width = .8) {
  result_var <- results_df %>% 
    filter(.width == width) %>% 
    pull(.variable) %>% 
    str_subset(iv)
  
  if (!type=="both") {
    res <- results_df %>% 
      filter(.variable == result_var & .width == width) %>% 
      pull({{type}})
  } else {
    sc <- results_df %>% 
      filter(.variable == result_var & .width == width) %>% 
      pull(std_coef)
    
    ci <- results_df %>% 
      filter(.variable == result_var & .width == width) %>% 
      pull(ci)
    
    wdth <- enexpr(width) * 100
    
    res <- paste0(sc, " (", wdth, "% c.i.: ", ci, ")")
  }
  
  return(res)
}

by2sd <- function(var) {
  dich <- stats::na.omit(unique(var)) %>% 
    sort() %>% identical(c(0, 1))
  if (dich) 
    sd <- 1
  else 
    sd <- 2 * stats::sd(var, na.rm = TRUE)
  
  return(sd)
}

set.seed(324)
descrep_path <- here("paper", "descriptive_representation")
policy_path <- here("paper", "policy_adoption")

oecd_countries <- c("Australia", "Austria", "Belgium",
                    "Canada", "Chile", "Colombia",
                    "Costa Rica", "Czechia", "Denmark",
                    "Estonia", "Finland", "France", 
                    "Germany", "Greece", "Hungary",
                    "Iceland", "Ireland", "Israel",
                    "Italy", "Japan", "South Korea",
                    "Latvia", "Lithuania", "Luxembourg",
                    "Mexico", "Netherlands", "New Zealand",
                    "Norway", "Poland", "Portugal", 
                    "Slovakia", "Slovenia", "Spain",
                    "Sweden", "Switzerland", "Turkey", 
                    "United Kingdom", "United States")
```


## Gender Quotas {.unnumbered}

<!-- Gender quotas: Weeks2018 -->

```{r quota_plot}
load(file = file.path(descrep_path, "data",  "by_country2.rda"))
load(file = file.path(descrep_path, "data",  "by_party2.rda"))

country_pge <- rio::import(file.path(descrep_path,
                       "data",
                       "country_pge.rda"))

country_quota_cor <- map(country_pge,
                         ~ with(.x, cor(pge_lag, national_quota,
                                        use = "pairwise.complete.obs"))) %>% 
  unlist() %>% 
  mean() %>% 
  round(2) %>% 
  sprintf("%.2f", .) %>% 
  paste0("R = ", .)

country_quota_label <- tibble(pge_lag = 90,
                              national_quota = 4,
                              label = country_quota_cor)

country_quota_plot <- ggplot(by_country2,
                             aes(x = pge_lag,
                                 y = national_quota)) +
  geom_segment(aes(x = pge_lag-2*pge_se_lag, xend = pge_lag+2*pge_se_lag,
                   y = national_quota, yend = national_quota),
               na.rm = TRUE,
               alpha = .2) +
  geom_point(alpha = .2) +
  geom_smooth(method = 'lm', se = FALSE) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=10),
        axis.title = element_text(size=12)) +
  scale_x_continuous(limits=c(25, 100),
                     breaks=seq(25, 100, by = 25)) +
  scale_y_continuous(limits=c(0, 51)) +
  labs(x = TeX("Public Gender Egalitarianism$_{t-1}$"), y = "National Quota") +
  geom_label(data = country_quota_label, aes(label = label))


party_pge <- rio::import(file.path(descrep_path,
                       "data",
                       "party_pge.rda"))

party_quota_cor <- map(party_pge,
                       ~ with(.x, cor(pge_lag, party_quota,
                                      use = "pairwise.complete.obs"))) %>% 
  unlist() %>% 
  mean() %>% 
  round(2) %>% 
  sprintf("%.2f", .) %>% 
  paste0("R = ", .)

party_quota_label <- tibble(pge_lag = 90,
                            party_quota = 4,
                            label = party_quota_cor)

party_quota_plot <- ggplot(by_party2,
                           aes(x = pge_lag,
                               y = party_quota)) +
  geom_segment(aes(x = pge_lag-2*pge_se_lag, xend = pge_lag+2*pge_se_lag,
                   y = party_quota, yend = party_quota),
               na.rm = TRUE,
               alpha = .05) +
  geom_point(alpha = .05) +
  geom_smooth(method = 'lm', se = FALSE) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=10),
        axis.title = element_text(size=12)) +
  scale_x_continuous(limits=c(25, 100),
                     breaks=seq(25, 100, by = 25)) +
  scale_y_continuous(limits=c(0, 51)) +
  labs(x = TeX("Public Gender Egalitarianism$_{t-1}$"), y = "Party Quota") +
  geom_label(data = party_quota_label, aes(label = label))

country_quota_plot + party_quota_plot
```

```{r quotas, eval=FALSE}
m0_party_quota <- party_pge %>%
  map(~ lmer(party_quota ~ pge_lag_by2sd +
               (1 | party) + (1 | cyear) + (1 | country), REML=FALSE,
             data = .x)) %>% 
  sim_and_tidy()

m1_party_quota <- party_pge %>%
  map(~ lmer(party_quota ~ pge_lag_by2sd +
               list +
               (1 | party) + (1 | cyear) + (1 | country), REML=FALSE,
             data = .x)) %>% 
  sim_and_tidy()

m2_party_quota <- party_pge %>%
  map(~ lmer(party_quota ~ pge_lag_by2sd +
               list +
               leftwing +
               pge_lag_by2sd:leftwing +
               (1 | party) + (1 | cyear) + (1 | country), REML=FALSE,
             data = .x)) %>% 
  sim_and_tidy()

m2_party_quota_a <- party_pge %>%
  map(~ lmer(party_quota ~ pge_lag +
               list +
               leftwing +
               pge_lag:leftwing +
               (1 | party) + (1 | cyear) + (1 | country), REML=FALSE,
             data = .x))

m3_party_quota <- party_pge %>%
  map(~ lmer(party_quota ~ pge_lag_by2sd +
               list +
               green +
               left +
               extreme_right +
               pge_lag_by2sd:green +
               pge_lag_by2sd:left +
               pge_lag_by2sd:extreme_right +
               (1 | party) + (1 | cyear) + (1 | country), REML=FALSE,
             data = .x)) %>% 
  sim_and_tidy()

m3_party_quota_a <- party_pge %>%
  map(~ lmer(party_quota ~ pge_lag +
               list +
               green +
               left +
               extreme_right +
               pge_lag:green +
               pge_lag:left +
               pge_lag:extreme_right +
               (1 | party) + (1 | cyear) + (1 | country), REML=FALSE,
             data = .x))

m02_party_quota <- bind_rows(m0_party_quota %>% 
                               mutate(model = "Model 0"),
                             m1_party_quota %>% 
                               mutate(model = "Model 1"),
                             m2_party_quota %>% 
                               mutate(model = "Model 2")) %>% 
  filter(!term=="(Intercept)")

quota_vars_proper <- c(bquote(PGE[t-1]),
                       "Party List",
                       "Leftwing Party",
                       bquote(PGE[t-1] %*% Leftwing~Party))

walk(1:3, function(mod) {
  m02_party_quota %>% 
    mutate(estimate = if_else(as.numeric(as_factor(model)) > mod,
                              NA_real_,
                              estimate),
           std.error = if_else(as.numeric(as_factor(model)) > mod,
                               NA_real_,
                               std.error)) %>% 
    dwplot() +
    scale_y_discrete(labels=do.call(expression, 
                                    rev(quota_vars_proper))) +
    theme_bw() +
    theme(legend.position="none",
          plot.title.position = "plot",
          axis.text  = element_text(size=12)) +
    geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
    coord_cartesian(xlim = c(min(m02_party_quota$estimate -
                                   1.96*m02_party_quota$std.error), 
                             max(m02_party_quota$estimate +
                                   1.96*m02_party_quota$std.error))) +
    scale_color_viridis_d(direction = -1,
                          end = .8) +
    xlab("Standardized Coefficients") +
    ggtitle("Multilevel Models of Gender Quotas")
  ggsave(here::here("paper",
                    "descriptive_representation",
                    paste0("m02_party_quota_", mod, ".jpg")))
})

interplot2(m2_party_quota_a, "leftwing", "pge_lag", hist = TRUE) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=10),
        axis.title = element_text(size=12)) +
  ylab("Coefficient for Leftwing Parties") +
  xlab(TeX("Public Gender Egalitarianism$_{t-1}$")) +
  geom_hline(yintercept = 0, colour = "grey60", linetype = 2) +
  ggtitle("Coefficients for Leftwing Parties\nby Public Gender Egalitarianism")
ggsave(file.path(descrep_path,
                 "quota_leftwing_by_pge.jpg"))

```

```{r quota_m1}
if (!file.exists(file.path(policy_path,  "data", "quota_m1_results.rda"))) {
  bf_national_quota <- bf(national_quota ~
                            me(pge_diff, pge_diff_se) +
                            me(pge_mean, pge_mean_se) +
                            fmi_diff +
                            fmi_mean +
                            list_diff +
                            list_mean +
                            (1|c|country) + (1|t|year))
  
  m1_national_quota_b <- brm(formula = bf_national_quota,
                             data = by_country2,
                             backend = "cmdstanr",
                             control=list(adapt_delta = 0.99, 
                                          max_treedepth = 15),
                             warmup = 500,
                             iter = 1000,
                             chains = 4,
                             cores = 4,
                             seed = 324)
  
  m1_data <- m1_national_quota_b$data
  
  m1_data_2sd <- m1_data %>% 
    select(-`national_quota`,
           -country, -year, -cyear, -party, -ends_with("_se")) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    mutate(`.variable` = case_when(name == "pge_mean" ~ 
                                     "bsp_mepge_meanpge_mean_se",
                                   name == "pge_diff" ~
                                     "bsp_mepge_diffpge_diff_se",
                                   TRUE ~ paste0("b_", name)),
           var_names = c("Feminist Movement Index, Difference",
                         "Feminist Movement Index, Country Mean",
                         "Electoral List, Difference",
                         "Electoral List, Country Mean",
                         "Public Gender Egalitarianism, Difference",
                         "Public Gender Egalitarianism, Country Mean"),
           sd2 = ifelse(str_detect(.variable, "list_|fmi_diff|_lag"),
                        1,
                        value))
  
  coef_data0_m1 <- m1_national_quota_b %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!`.variable`=="b_Intercept") %>% 
    left_join(m1_data_2sd, by = join_by(.variable))
  
  save(m1_national_quota_b, m1_data_2sd, coef_data0_m1, 
       file = file.path(policy_path, "data",  "quota_m1_results.rda"))
} else {
  load(file = file.path(policy_path, "data",  "quota_m1_results.rda"))
}
```

```{r quota_m2}
if (!file.exists(file.path(policy_path,  "data", "quota_m1_results.rda"))) {
  bf_party_quota <- bf(party_quota ~
                         me(pge_diff, pge_diff_se) +
                         me(pge_mean, pge_mean_se) +
                         fmi_diff +
                         fmi_mean +
                         list_diff +
                         list_mean +
                         left +
                         green +
                         center +
                         extreme_right +
                         (1|p|party) + (1|cy|cyear) + (1|c|country) + (1|t|year))
  
  m2_party_quota_b <- brm(formula = bf_party_quota,
                          data = by_party2,
                          backend = "cmdstanr",
                          control=list(adapt_delta = 0.99, 
                                       max_treedepth = 15),
                          warmup = 500,
                          iter = 1000,
                          chains = 4,
                          cores = 4,
                          seed = 324)
  
  m2_data <- m2_party_quota_b$data
  
  m2_data_2sd <- m2_data %>% 
    select(-`party_quota`,
           -country, -year, -cyear, -party, -ends_with("_se")) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    mutate(`.variable` = case_when(name == "pge_mean" ~ 
                                     "bsp_mepge_meanpge_mean_se",
                                   name == "pge_diff" ~
                                     "bsp_mepge_diffpge_diff_se",
                                   TRUE ~ paste0("b_", name)),
           var_names = c("Feminist Movement Index, Difference",
                         "Feminist Movement Index, Country Mean",
                         "Electoral List, Difference",
                         "Electoral List, Country Mean",
                         "Left Party",
                         "Green Party",
                         "Center Party",
                         "Extreme Right Party",
                         "Public Gender Egalitarianism, Difference",
                         "Public Gender Egalitarianism, Country Mean"),
           sd2 = ifelse(str_detect(.variable, "list_|fmi_diff|_lag"),
                        1,
                        value))
  
  coef_data0_m2 <- m2_party_quota_b %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!`.variable`=="b_Intercept") %>% 
    left_join(m2pf_data_2sd, by = join_by(.variable))
  
  save(m2_party_quota_b, m2_data_2sd, coef_data0_m2, 
       file = file.path(policy_path, "data",  "quota_m2_results.rda"))
} else {
  load(file = file.path(descrep_path, "data",  "by_party2.rda"))
  load(file = file.path(policy_path, "data",  "quota_m2_results.rda"))
}
```

## Policies Addressing Violence Against Women {.unnumbered}
<!-- Anti-violence against women -->

## Workplace Equality and Family Leave {.unnumbered}
<!-- Family leave -->
<!-- Gender equality of opportunity: see Kim2022 and https://wbl.worldbank.org/en/wbl  -->
