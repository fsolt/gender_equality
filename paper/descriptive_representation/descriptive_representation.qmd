---
format:
  html:
    theme: cosmo
  pdf:
    documentclass: scrbook
    linestretch: "1.5"
---

# Gender Egalitarianism and Women's Descriptive Representation

This chapter takes up the question of the role of public attitudes in the election of women to legislative office.


And what part do public attitudes toward gender roles play in the process?
Cross-national research has been constrained to study countries at just one or a few time points [see, e.g., @Paxton2003; @Alexander2012] or to rely on proxies such as predominant religion or the percentage of women in office [see, e.g., @Burns2001, 340-341; @Claveria2014; @Barnes2018].
Cross-national and longitudinal investigation of, for example, the argument that such "attitudes influence both the supply of, and demand for, female candidates" has remained persistently a topic for future research [@Paxton2010, 47].
Recall that a big reason why previous scholarship offers little about whether or how public attitudes might play a role is due to the inability to measure these attitudes very effectively.
The PGE data presented in the previous chapter provides us, for the first time, with the data we need to get answers. 

Descriptive representation is the extent to which people in positions of power share traits with those who elect them.
@Mansbridge1999

The theory connecting gender egalitarianism in the public sphere with women's descriptive representation is straightforward.
Where the public holds more egalitarian views toward women in politics and the workforce, voters will be more willing to elect female candidates running for office, and party gatekeepers will be more willing to allow them to run.
In other words, more egalitarianism should be expected to increase both demand and supply, with the consequence that more women will hold office.




```{r setup, include=FALSE}
options(tinytex.verbose = TRUE)

knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  dpi = 300,
  fig.width=7
)

if (!require(pacman))
  install.packages("pacman")
library(pacman)

p_install(janitor, force = FALSE)

p_load(
  # analysis
  brms,
  
  # presentation
  gridExtra,
  modelsummary,
  dotwhisker,
  ggthemes,
  latex2exp,
  RColorBrewer,
  colorRamps,
  directlabels,
  patchwork,
  
  # data wrangling
  broom,
  countrycode,
  DCPOtools,
  glue,
  here,
  janitor,
  tidyverse,
  wbstats)

interplot2 <- function (m, var1, var2, plot = TRUE, steps = NULL, ci = 0.95, 
                        adjCI = FALSE, hist = FALSE, var2_dt = NA, predPro = FALSE, 
                        var2_vals = NULL, point = FALSE, sims = 5000, xmin = NA, 
                        xmax = NA, ercolor = NA, esize = 0.5, ralpha = 0.5, rfill = "grey70", 
                        stats_cp = "none", txt_caption = NULL, facet_labs = NULL, 
                        ...) {
  m.class <- class(m)
  if (m.class == "list") {
    m.sims <- m %>% 
      map_df(~ arm::sim(.x, sims/100) %>% 
               pluck("fixef") %>% 
               as_tibble())
    m <- m[[1]]
  } else m.sims <- arm::sim(m, sims) %>% 
      pluck("fixef") %>% 
      as_tibble()
  factor_v1 <- factor_v2 <- FALSE
  if (is.factor(eval(parse(text = paste0("m@frame$", var1)))) & 
      is.factor(eval(parse(text = paste0("m@frame$", var2))))) 
    stop("The function does not support interactions between two factors.")
  if (is.factor(eval(parse(text = paste0("m@frame$", var1))))) {
    var1_bk <- var1
    var1 <- paste0(var1, levels(eval(parse(text = paste0("m@frame$", 
                                                         var1)))))
    factor_v1 <- TRUE
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2, ":", var1)[-1])
    for (i in seq(var12)) {
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        var12[i] <- paste0(var1, ":", var2)[-1][i]
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    }
  } else if (is.factor(eval(parse(text = paste0("m@frame$", 
                                                var2))))) {
    var2_bk <- var2
    var2 <- paste0(var2, levels(eval(parse(text = paste0("m@frame$", 
                                                         var2)))))
    factor_v2 <- TRUE
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2, ":", var1)[-1])
    for (i in seq(var12)) {
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        var12[i] <- paste0(var1, ":", var2)[-1][i]
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    }
  } else {
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2, ":", var1))
    for (i in seq(var12)) {
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        var12[i] <- paste0(var1, ":", var2)[i]
      if (!var12[i] %in% unlist(dimnames(m@pp$X)[2])) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    }
  }
  if (factor_v2) {
    xmin <- 0
    xmax <- 1
    steps <- 2
  } else {
    if (is.na(xmin)) 
      xmin <- min(m@frame[var2], na.rm = T)
    if (is.na(xmax)) 
      xmax <- max(m@frame[var2], na.rm = T)
    if (is.null(steps)) {
      steps <- eval(parse(text = paste0("length(unique(na.omit(m@frame$", 
                                        var2, ")))")))
    }
    if (steps > 100) 
      steps <- 100
  }
  coef <- data.frame(fake = seq(xmin, xmax, length.out = steps), 
                     coef1 = NA, ub = NA, lb = NA)
  coef_df <- data.frame(fake = numeric(0), coef1 = numeric(0), 
                        ub = numeric(0), lb = numeric(0), model = character(0))
  if (factor_v1) {
    if (predPro == TRUE) 
      stop("The current version does not support estimating predicted probabilities for factor base terms.")
    for (j in 1:(length(levels(eval(parse(text = paste0("m@frame$", 
                                                        var1_bk))))) - 1)) {
      for (i in 1:steps) {
        coef$coef1[i] <- mean(first(m.sims[, match(var1[j + 
                                                          1], unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                      m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]))
        coef$ub[i] <- quantile(first(m.sims[, match(var1[j + 
                                                           1], unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               (1 - ci)/2)
        coef$lb[i] <- quantile(first(m.sims[, match(var1[j + 
                                                           1], unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               1 - (1 - ci)/2)
      }
      if (plot == TRUE) {
        coef$value <- var1[j + 1]
        coef_df <- rbind(coef_df, coef)
        if (hist == TRUE) {
          if (is.na(var2_dt)) {
            var2_dt <- eval(parse(text = paste0("m@frame$", 
                                                var2)))
          }
          else {
            var2_dt <- var2_dt
          }
        }
      }
      else {
        names(coef) <- c(var2, "coef", "ub", "lb")
        return(coef)
      }
    }
    if (is.null(facet_labs)) 
      facet_labs <- unique(coef_df$value)
    coef_df$value <- factor(coef_df$value, labels = facet_labs)
    interplot:::interplot.plot(m = coef_df, hist = hist, steps = steps, 
                               var2_dt = var2_dt, point = point, ercolor = ercolor, 
                               esize = esize, ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                               txt_caption = NULL, ...) + facet_grid(. ~ value)
  } else if (factor_v2) {
    if (predPro == TRUE) 
      stop("The current version does not support estimating predicted probabilities for factor base terms.")
    for (j in 1:(length(levels(eval(parse(text = paste0("m@frame$", 
                                                        var2_bk))))) - 1)) {
      for (i in 1:steps) {
        coef$coef1[i] <- mean(first(m.sims[, match(var1, 
                                                   unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                      m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]))
        coef$ub[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               (1 - ci)/2)
        coef$lb[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + coef$fake[i] * 
                                       m.sims[, match(var12[j], unlist(dimnames(m@pp$X)[2]))]), 
                               1 - (1 - ci)/2)
      }
      if (plot == TRUE) {
        coef$value <- var2[j + 1]
        coef_df <- rbind(coef_df, coef)
        if (hist == TRUE) {
          if (is.na(var2_dt)) {
            var2_dt <- eval(parse(text = paste0("m@frame$", 
                                                var2)))
          }
          else {
            var2_dt <- var2_dt
          }
        }
      }
      else {
        names(coef) <- c(var2, "coef", "ub", "lb")
        return(coef)
      }
    }
    if (is.null(facet_labs)) 
      facet_labs <- unique(coef_df$value)
    coef_df$value <- factor(coef_df$value, labels = facet_labs)
    interplot:::interplot.plot(m = coef_df, steps = steps, hist = hist, 
                               var2_dt = var2_dt, point = point, ercolor = ercolor, 
                               esize = esize, ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                               txt_caption = NULL, ...) + facet_grid(. ~ value)
  } else {
    if (predPro == TRUE) {
      if (is.null(var2_vals)) 
        stop("The predicted probabilities cannot be estimated without defining 'var2_vals'.")
      df <- data.frame(m$model)
      df[[names(m@flist)]] <- NULL
      if (sum(grep("X.weights.", names(df))) != 0) 
        df <- select(df, -X.weights.)
      df_temp <- select(df, 1)
      df <- df[-1] %>% map(function(var) {
        if (is.factor(var)) {
          model.matrix(~var - 1)[, -1] %>% as.data.frame()
        }
        else {
          as.numeric(var)
        }
      })
      for (i in seq(df)) {
        if (!is.data.frame(df[[i]])) {
          namesUpdate <- c(names(df_temp), names(df)[[i]])
          df_temp <- cbind(df_temp, df[[i]])
          names(df_temp) <- namesUpdate
        }
        else {
          df_temp <- cbind(df_temp, df[[i]])
        }
      }
      df <- df_temp
      names(df)[1] <- "(Intercept)"
      df$`(Intercept)` <- 1
      if (var1 == var2) {
        names(df) <- sub("I\\.(.*)\\.2\\.", "I\\(\\1\\^2\\)", 
                         names(df))
      }
      iv_medians <- summarize_all(df, funs(median(., na.rm = TRUE)))
      fake_data <- iv_medians[rep(1:nrow(iv_medians), 
                                  each = steps * length(var2_vals)), ]
      fake_data[[var1]] <- with(df, rep(seq(min(get(var1)), 
                                            max(get(var1)), length.out = steps), steps = length(var2_vals)))
      fake_data[[var2]] <- rep(var2_vals, each = steps)
      fake_data[[var12]] <- fake_data[[var1]] * fake_data[[var2]]
      pp <- rowMeans(plogis(data.matrix(fake_data) %*% 
                              t(data.matrix(m.sims))))
      row_quantiles <- function(x, probs) {
        naValue <- NA
        storage.mode(naValue) <- storage.mode(x)
        nrow <- nrow(x)
        q <- matrix(naValue, nrow = nrow, ncol = length(probs))
        if (nrow > 0L) {
          t <- quantile(x[1L, ], probs = probs)
          colnames(q) <- names(t)
          q[1L, ] <- t
          if (nrow >= 2L) {
            for (rr in 2:nrow) {
              q[rr, ] <- quantile(x[rr, ], probs = probs)
            }
          }
        }
        else {
          t <- quantile(0, probs = probs)
          colnames(q) <- names(t)
        }
        q <- drop(q)
        q
      }
      pp_bounds <- row_quantiles(plogis(data.matrix(fake_data) %*% 
                                          t(data.matrix(m.sims))), prob = c((1 - 
                                                                               ci)/2, 1 - (1 - ci)/2))
      pp <- cbind(pp, pp_bounds)
      pp <- pp * 100
      colnames(pp) <- c("coef1", "lb", "ub")
      pp <- cbind(fake_data[, c(var1, var2)], pp)
      pp[, var2] <- as.factor(pp[, var2])
      names(pp)[1] <- "fake"
      names(pp)[2] <- "value"
      coef <- pp
    } else {
      multiplier <- ifelse(var1 == var2, 2, 1) 
      
      for (i in 1:steps) {
        coef$coef1[i] <- mean(first(m.sims[, match(var1, 
                                                   unlist(dimnames(m@pp$X)[2]))] + {multiplier * 
                                                       coef$fake[i] * m.sims[, match(var12, 
                                                                                     unlist(dimnames(m@pp$X)[2]))]}))
        coef$ub[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + multiplier * 
                                       coef$fake[i] * m.sims[, match(var12, 
                                                                     unlist(dimnames(m@pp$X)[2]))]), (1 - ci)/2)
        coef$lb[i] <- quantile(first(m.sims[, match(var1, 
                                                    unlist(dimnames(m@pp$X)[2]))] + multiplier * 
                                       coef$fake[i] * m.sims[, match(var12, 
                                                                     unlist(dimnames(m@pp$X)[2]))]), 1 - (1 - ci)/2)
      }
    }
    multiplier <- ifelse(var1 == var2, 2, 1) 
    min_sim <- m.sims[, match(var1, unlist(dimnames(m@pp$X)[2]))] + 
      multiplier * xmin * m.sims[, match(var12, 
                                         unlist(dimnames(m@pp$X)[2]))]
    max_sim <- m.sims[, match(var1, unlist(dimnames(m@pp$X)[2]))] + 
      multiplier * xmax * m.sims[, match(var12, 
                                         unlist(dimnames(m@pp$X)[2]))]
    diff <- first(max_sim - min_sim)
    ci_diff <- c(quantile(diff, (1 - ci)/2), quantile(diff, 
                                                      1 - (1 - ci)/2))
    if (plot == TRUE) {
      if (hist == TRUE) {
        if (is.na(var2_dt)) {
          var2_dt <- eval(parse(text = paste0("m@frame$", 
                                              var2)))
        }
        else {
          var2_dt <- var2_dt
        }
      }
      interplot:::interplot.plot(m = coef, steps = steps, hist = hist, 
                                 predPro = predPro, var2_vals = var2_vals, var2_dt = var2_dt, 
                                 point = point, ercolor = ercolor, esize = esize, 
                                 ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                                 txt_caption = NULL, ...)
    } else {
      if (predPro == TRUE) {
        names(coef) <- c(var2, paste0("values_in_", 
                                      var1), "coef", "ub", "lb")
      }
      else {
        names(coef) <- c(var2, "coef", "ub", "lb")
      }
      return(coef)
    }
  }
}

interplot_b <- function (m, var1, var2, plot = TRUE, steps = NULL, ci = 0.95, 
                         adjCI = FALSE, hist = FALSE, var2_dt = NA, predPro = FALSE, 
                         var2_vals = NULL, point = FALSE, sims = 5000, xmin = NA, 
                         xmax = NA, ercolor = NA, esize = 0.5, ralpha = 0.5, rfill = "grey70", 
                         stats_cp = "none", txt_caption = NULL, facet_labs = NULL, 
                         ...) {
    
    m.sims <- brms::as_draws_df(m) %>% 
        as_tibble()
    
    if (is.na(xmin)) 
        xmin <- min(m$data[var2], na.rm = TRUE)
    if (is.na(xmax)) 
        xmax <- max(m$data[var2], na.rm = TRUE)
    if (is.null(steps)) {
        steps <- eval(parse(text = paste0("length(unique(na.omit(m$data$", 
                                          var2, ")))")))
    }
    if (steps > 100) 
        steps <- 100
    
    coef <- data.frame(fake = seq(xmin, xmax, length.out = steps), 
                       coef1 = NA, ub = NA, lb = NA)
    coef_df <- data.frame(fake = numeric(0), coef1 = numeric(0), 
                          ub = numeric(0), lb = numeric(0), model = character(0))
    
    var1a <- str_subset(names(m.sims), var1)[1]
    var2a <- str_subset(names(m.sims), var2)[1]
    ifelse(var1 == var2, var12 <- paste0("I(", var1, "^2)"), 
           var12 <- paste0(var2a, ":", var1))
    if (!var12 %in% names(m.sims))
        var12 <- paste0(var1a, ":", var2)
    if (!var12 %in% names(m.sims)) 
        stop(paste("Model does not include the interaction of", 
                   var1, "and", var2, "."))
    
    multiplier <- ifelse(var1 == var2, 2, 1) 
    
    for (i in 1:steps) {
        coef$coef1[i] <- mean({m.sims[, var1a] + {multiplier * 
                coef$fake[i] * m.sims[, var12]}}[, 1])
        coef$lb[i] <- quantile({m.sims[, var1a] + {multiplier * 
                coef$fake[i] * m.sims[, var12]}}[, 1], (1 - ci)/2)
        coef$ub[i] <- quantile({m.sims[, var1a] + {multiplier * 
                coef$fake[i] * m.sims[, var12]}}[, 1], 1 - (1 - ci)/2)
    }
    
    min_sim <- {m.sims[, var1a] + {multiplier * 
            xmin * m.sims[, var12]}}[, 1]
    max_sim <- {m.sims[, var1a] + {multiplier * 
            xmax * m.sims[, var12]}}[, 1]
    diff <- first(max_sim - min_sim)
    ci_diff <- c(quantile(diff, (1 - ci)/2), quantile(diff, 
                                                      1 - (1 - ci)/2))
    if (plot == TRUE) {
        interplot:::interplot.plot(m = coef, steps = steps, hist = hist, 
                                   predPro = predPro, var2_vals = var2_vals, var2_dt = var2_dt, 
                                   point = point, ercolor = ercolor, esize = esize, 
                                   ralpha = ralpha, rfill = rfill, stats_cp = "none", 
                                   txt_caption = NULL, ...)
    } else {
        names(coef) <- c(var2, "coef", "ub", "lb")
        return(coef)
    }
}


make_dummies <- function(df, col) {
  x <- df[[col]]
  mm <- model.matrix(~ x - 1)
  colnames(mm) <- str_replace(colnames(mm), "^x", "") %>% 
    str_replace(" ", "_")
  
  bind_cols(df, mm)
}

get_coef <- function(iv, results_df = coef_data, type = "both", width = .95) {
  result_var <- results_df %>% 
    filter(.width == width) %>% 
    pull(.variable) %>% 
    str_subset(iv)
  
  if (!type=="both") {
    res <- results_df %>% 
      filter(.variable == result_var & .width == width) %>% 
      pull({{type}})
  } else {
    sc <- results_df %>% 
      filter(.variable == result_var & .width == width) %>% 
      pull(std_coef)
    
    ci <- results_df %>% 
      filter(.variable == result_var & .width == width) %>% 
      pull(ci)
    
    res <- paste0(sc, " (95% c.i.: ", ci, ")")
  }
  
  return(res)
}

by2sd <- function(var) {
  dich <- stats::na.omit(unique(var)) %>% 
    sort() %>% identical(c(0, 1))
  if (dich) 
    sd <- 1
  else 
    sd <- 2 * stats::sd(var, na.rm = TRUE)
  
  return(sd)
}

set.seed(324)
descrep_path <- here("paper", "descriptive_representation")

oecd_countries <- c("Australia", "Austria", "Belgium",
                    "Canada", "Chile", "Colombia",
                    "Costa Rica", "Czechia", "Denmark",
                    "Estonia", "Finland", "France", 
                    "Germany", "Greece", "Hungary",
                    "Iceland", "Ireland", "Israel",
                    "Italy", "Japan", "South Korea",
                    "Latvia", "Lithuania", "Luxembourg",
                    "Mexico", "Netherlands", "New Zealand",
                    "Norway", "Poland", "Portugal", 
                    "Slovakia", "Slovenia", "Spain",
                    "Sweden", "Switzerland", "Turkey", 
                    "United Kingdom", "United States")
```
## Comparing Countries Over Time {.unnumbered}

### Data {.unnumbered}
```{r load_party_data, eval=FALSE}

# Party-level
# Manifesto Project: parties and election results
if (!file.exists(file.path(descrep_path,
                           "data-raw",
                           "manifesto_project",
                           "mpds2021a.csv"))) {
  download.file("https://manifesto-project.wzb.eu/down/data/2021a/datasets/MPDataset_MPDS2021a.csv",
                file.path(descrep_path, "data-raw", "manifesto_project", "mpds2021a.csv"))
}

mp_parties <- read_csv(file.path(descrep_path,
                                 "data-raw",
                                 "manifesto_project",
                                 "mpds2021a.csv"),
                       show_col_types = FALSE) %>%
  mutate(year = round(as.numeric(date)/100)) %>% 
  select(country, countryname, eumember, 
         date, year,
         party, partyname, partyabbrev, parfam,
         pervote, absseat, totseats,
         rile) %>% 
  arrange(party, -date) %>% 
  distinct(party, year, .keep_all = TRUE) %>% #use later of 2 elections in year
  arrange(party, date)

# Original data on Colombia and Costa Rica (not included in MP)
latam <- read_csv(file.path(descrep_path,
                            "data-raw",
                            "latam.csv"),
                  col_types = "cddcddcddd")

# Continuity: fixes to MP parties
party_continuity <- read_csv(file.path(descrep_path,
                                       "data-raw",
                                       "party_continuity.csv"),
                             show_col_types = FALSE) %>% 
  select(-partyname)

# Weeks, Meguid, Kittilson, and Coffé 2022 (from Dataverse): 
# women elected and female leadership
weeks <- rio::import(file.path(descrep_path,
                               "data-raw",
                               "WeeksMeguidKittilsonCoffe2022",
                               "Replication_data.RData")) %>%
  mutate(year = round(as.numeric(date)/100)) %>% 
  select(weurope, party, 
         date,
         pfem_c = pfem_new2, femaleleader_c = femaleleader2_lag,
         cabinet_party_c = cabinet_party2_lag) %>% 
  distinct() %>% 
  mutate(source = "https://doi.org/10.1017/S0003055422000107")

# Adams, Bracken, Gidron, Horne, and O’BrienSenk 2022 (from Dataverse):
# women elected and female leadership

previous_election <- mp_parties %>% 
  group_by(party) %>% 
  mutate(date = date,
         date_lag = lag(date),
         year_lag = round(as.numeric(date_lag)/100)) %>% 
  distinct(party, year, .keep_all = TRUE ) %>% 
  select(party, date, year, date_lag, year_lag)

adams0 <- rio::import(file.path(descrep_path,
                                "data-raw",
                                "AdamsBrackenGidronHorneOBrienSenk2022",
                                "dyadic_data_1-4-22.Rdata")) %>%
  filter(!is.na(to_pfeml)) %>%
  transmute(countryname = countrycode::countrycode(country,
                                                   "country.name",
                                                   "country.name"),
            year = year,
            party = to_mp_number,
            pfem_b = to_pfeml*100,
            femaleleader_b = to_femaleleader,
            cabinet_party_b = to_in_gov) %>%
  arrange(countryname, year, party) %>% 
  distinct() %>% 
  left_join(previous_election,
            by = c("party", "year")) 

adams <- anti_join(adams0, adams0 %>% filter(year == year_lag),
                   by = names(adams0)) %>% 
  select(date = date_lag, party, pfem_b, femaleleader_b, cabinet_party_b) %>% 
  mutate(source = "https://doi.org/10.1017/S0003055422000491")

rm(adams0)

# Australia: women elected and female leadership
australia <- rvest::session("https://en.wikipedia.org/wiki/Women_in_the_Australian_House_of_Representatives") %>% 
  rvest::html_table() %>% 
  nth(2) %>% 
  janitor::clean_names() %>% 
  mutate(year = str_extract(election, "\\d{4}") %>% 
           as.numeric()) %>% 
  select(year, labor_3, liberal_3, national_3) %>% 
  filter(year > 1970 & !is.na(year)) %>% 
  rename_with(., ~c("Australian Labor Party",
                    "Liberal Party of Australia",
                    "National Party of Australia"), names(.)[2:4]) %>% 
  pivot_longer(cols = !year, 
               names_to = "partyname",
               values_to = "pfem0") %>% 
  mutate(pfem_a = str_extract(pfem0, "\\d{1,2}\\.?\\d?") %>% 
           as.numeric()) %>% 
  filter(!is.na(year) & !is.na(pfem_a)) %>% 
  select(-pfem0) %>% 
  left_join(tibble(party = c(63320,
                             63620,
                             63810), 
                   partyname = c("Australian Labor Party",
                                 "Liberal Party of Australia",
                                 "National Party of Australia")),
            by = "partyname") %>% 
  mutate(femaleleader_a = case_when(party == 63320 ~ as.numeric(year==2010),
                                    party == 63620 ~ 0,
                                    party == 63810 ~ 0)) %>% 
  bind_rows(tibble(party = 63110,
                   partyname = "Australian Greens",
                   year = c(2004, 2007, 2010, 2013, 2016, 2019, 2022),
                   pfem_a = c(NA, NA, 0, 0, 0, 0, 25),
                   femaleleader_a = c(0, 0, 0, 1, 0, 0, 0))) %>% 
  bind_rows(tibble(party = 63710,
                   partyname = "Katter's Australian Party",
                   year = c(2010, 2013, 2016, 2019, 2022),
                   pfem_a = c(NA, 0, 0, 0, 0),
                   femaleleader_a = c(0, 0, 0, 0, 0))) %>% 
  bind_rows(tibble(party = 63410,
                   partyname = "Palmer United Party",
                   year = c(2013),
                   pfem_a = c(0),
                   femaleleader_a = c(0))) %>% 
  bind_rows(tibble(party = 63621,
                   partyname = "Liberal National Party of Queensland",
                   year = c(2010, 2013, 2016),
                   pfem_a = c(0, 0, 0),
                   femaleleader_a = c(0, 0, 0))) %>% 
  bind_rows(tibble(party = 63901,
                   partyname = "Nick Xenophon Team",
                   year = c(2016, 2019, 2022),
                   pfem_a = c(100, 100, 100),
                   femaleleader_a = c(0, 0, 0))) %>% 
  mutate(countryname = "Australia",
         source = "https://en.wikipedia.org/wiki/Women_in_the_Australian_House_of_Representatives")

# Germany: women elected and female leadership
germany <- rvest::session("https://de.wikipedia.org/wiki/Frauenanteil_im_Deutschen_Bundestag_seit_1949") %>% 
  rvest::html_table() %>% 
  nth(2) %>% 
  janitor::clean_names() %>% 
  mutate(year = str_extract(wahlperiode, "\\d{4}") %>% 
           as.numeric()) %>% 
  select(-wahlperiode, -contains("_2")) %>% 
  rename_with(., ~c("Christian Democratic Union/Christian Social Union",
                    "Free Democratic Party",
                    "Social Democratic Party of Germany",
                    "Alliance‘90/Greens", "The Left",
                    "Alternative for Germany"), names(.)[1:6]) %>% 
  pivot_longer(cols = !year, 
               names_to = "partyname",
               values_to = "pfem0") %>% 
  mutate(pfem_a = str_extract(pfem0, "\\d{1,2},?\\d?") %>% 
           str_replace(",", ".") %>% 
           as.numeric()) %>% 
  filter(!is.na(year) & !is.na(pfem_a)) %>% 
  select(-pfem0) %>% 
  left_join(tibble(party = c(41521, 
                             41420, 
                             41320,
                             41113, 41223,
                             41953), 
                   partyname = c("Christian Democratic Union/Christian Social Union",
                                 "Free Democratic Party",
                                 "Social Democratic Party of Germany",
                                 "Alliance‘90/Greens", "The Left",
                                 "Alternative for Germany")),
            by = "partyname") %>% 
  mutate(femaleleader_a = case_when(party == 41521 ~ as.numeric(between(year, 2005, 2017)),
                                    party == 41420 ~ 0,
                                    party == 41320 ~ 0,
                                    party == 41113 ~ as.numeric(year!=1990),
                                    party == 41223 ~ as.numeric(year==2021),
                                    party == 41953 ~ as.numeric(year!=2013)),
         countryname = "Germany",
         source = "https://de.wikipedia.org/wiki/Frauenanteil_im_Deutschen_Bundestag_seit_1949")

# United States: women elected and female leadership
united_states <- rvest::session("https://en.wikipedia.org/wiki/Women_in_the_United_States_House_of_Representatives") %>% 
  rvest::html_table() %>% 
  nth(5) %>% 
  janitor::clean_names() %>% 
  mutate(year = str_extract(years, "\\d{4}") %>% 
           as.numeric() - 1) %>% 
  select(year,
         `Republican Party` = percent_of_party,
         `Democratic Party` = percent_of_party_2) %>% 
  pivot_longer(cols = !year, 
               names_to = "partyname",
               values_to = "pfem0") %>% 
  mutate(pfem_a = str_extract(pfem0, "\\d{1,2}\\.?\\d?") %>% 
           as.numeric()) %>% 
  select(-pfem0) %>% 
  left_join(tibble(party = c(61320, 
                             61620), 
                   partyname = c("Democratic Party",
                                 "Republican Party")),
            by = "partyname") %>% 
  mutate(femaleleader_a = case_when(party == 61320 ~ as.numeric(year==2016),
                                    party == 61620 ~ 0),
         countryname = "United States",
         source = "https://en.wikipedia.org/wiki/Women_in_the_United_States_House_of_Representatives")

# Original updates to women elected and female leadership
updates <- read_csv(file.path(descrep_path,
                              "data-raw",
                              "pfem_updates.csv"),
                    col_types = "cdddcdcdd")

# Country-level
# Parline: updated country-level women legislators

if (!file.exists(file.path(descrep_path, "data-raw", "parline.rda"))) {
  clean_old_parline <- function(yyyy) {
    rvest::session(paste0("http://archive.ipu.org/wmn-e/arc/classif0101", 
                          yyyy - 1999,
                          ".htm")) %>% 
      rvest::html_table() %>% 
      nth(3) %>% 
      row_to_names(3) %>% 
      clean_names() %>% 
      transmute(country = countrycode(country, "country.name", "country.name"),
                year = yyyy,
                women_rep = percent_w %>% 
                str_remove("%") %>% 
                as.numeric())
  }
  
  clean_new_parline <- function(yyyy) {
    download.file(paste0("https://data.ipu.org/api/women-ranking.csv?load-entity-refs=taxonomy_term%2Cfield_collection_item&max-depth=2&langcode=en&month=1&year=", 
                         yyyy + 1),
                  file.path(descrep_path,
                            "data-raw",
                            paste0("parline", yyyy, ".csv")))
    
    read_csv(file.path(descrep_path,
                       "data-raw",
                       paste0("parline", yyyy, ".csv")),
             skip = 5) %>%
      clean_names() %>% 
      transmute(country = countrycode(x2, "country.name", "country.name"),
                year = yyyy,
                women_rep = percent_w_6 %>% 
                str_remove("%") %>% 
                as.numeric())
  }
  
  parline <- map(2016:2018, clean_old_parline) %>% 
    list_rbind() %>% 
    bind_rows(map(2019:2022, clean_new_parline) %>% 
              list_rbind()) %>% 
    arrange(country, year) %>% 
    mutate(women_rep = ifelse(is.na(women_rep),
                              lead(women_rep),
                              women_rep))
  save(parline, file = file.path(descrep_path, "data-raw", "parline.rda"))
} else {
  load(file.path(descrep_path, "data-raw", "parline.rda"))
}

# QAROT: national quotas and women's representation (plus Parline updates)
qarot <- read_csv(file.path(descrep_path,
                            "data-raw", 
                            "qarot",
      "QAROTdata_HughesPaxtonClaytonZetterberg_CountryYear_V1_August2017.csv"),
                  show_col_types = FALSE) %>%  # http://doi.org/10.3886/E100918V1
  mutate(countryname = countrycode::countrycode(country,
                                                origin = "country.name",
                                                destination = "country.name")) %>% 
  janitor::clean_names() %>% 
  select(countryname, year, defacto_threshold, women_rep) %>% 
  mutate(defacto_threshold = if_else(is.na(defacto_threshold), 0, defacto_threshold)) %>% 
  group_by(countryname) %>% 
  group_modify(~ add_row(.x,
                         year = 2016:2023)) %>% 
  fill(defacto_threshold) %>% 
  mutate(defacto_threshold = case_when(countryname == "Colombia" &
                                         defacto_threshold == 30 ~ 37,
                                       countryname == "France" &
                                         defacto_threshold == 50 ~ 48,
                                       countryname == "Hungary" &
                                         year >= 2011 ~ 35,
                                       countryname == "Ireland" &
                                         year >= 2023 ~ 40,
                                       countryname == "Luxembourg" &
                                         year >= 2016 ~ 40,
                                       countryname == "Portugal" &
                                         year >= 2019 ~ 40,
                                       TRUE ~ defacto_threshold)) %>% 
  left_join(parline, by = c("countryname" = "country", "year")) %>% 
  mutate(women_rep = if_else(!is.na(women_rep.x),
                             women_rep.x,
                             women_rep.y)) %>% 
  select(-women_rep.x, -women_rep.y)


# Party Quotas (compilation)
party_quotas <- read_csv(file.path(descrep_path,
                                   "data-raw",
                                   "party_quotas.csv"),
                         col_types = "cdcddc") %>% 
  select(countryname, party_quota, adoption_year, party) %>% 
  filter(!is.na(party_quota)) %>% 
  group_by(countryname, party, party_quota) %>% 
  mutate(year = list(seq(adoption_year, 
                         Sys.Date() %>%
                           str_extract("\\d{4}") %>%
                           as.numeric())),
         countryname = countrycode::countrycode(countryname,
                                                "country.name",
                                                "country.name"),
         party_quota = round(party_quota)) %>% 
  unnest(year) %>% 
  ungroup() %>% 
  group_by(countryname, party, year) %>% 
  arrange(-adoption_year) %>%
  slice(1) %>%
  ungroup() %>% 
  select(-adoption_year)

# Borman and Golder: electoral systems
des <- rio::import(file.path(descrep_path,
                             "data-raw",
                             "des",
                             "es_data-v4_1.csv")) %>% 
  filter(presidential == 0) %>% 
  mutate(date = mdy(date)) %>% 
  arrange(country, desc(date)) %>% 
  distinct(country, year, .keep_all = TRUE) %>% 
  transmute(countryname = countrycode::countrycode(country,
                                                   "country.name",
                                                   "country.name",
                                                   warn = FALSE),
            year = year,
            list_pr = as.numeric(elecrule == 9),
            mmp = as.numeric(elecrule == 11),
            mmm = as.numeric(elecrule == 12),
            list = pmax(list_pr, mmp, mmm),
            tier1_avemag = tier1_avemag)

if (!file.exists(file.path(descrep_path, "data-raw", "gdppc.rda"))) {
  gdppc <- wbstats::wb_data(indicator = "NY.GDP.PCAP.CD") %>% 
    transmute(iso2c, 
              gdppc = value, 
              year = as.numeric(date))
  save(gdppc, file = file.path(descrep_path, "data-raw", "gdppc.rda"))
} else {
  load(file.path(descrep_path, "data-raw", "gdppc.rda"))
}
```

```{r join_data, eval=FALSE}
# PGE: gender egalitarianism
pge <- rio::import(here("data",
                        "pge.rda"))

pge_summary <- rio::import(here("data",
                                "pge_summary.rda")) %>% 
  group_by(country) %>% 
  mutate(across(starts_with("p"),
                ~ lag(.x) * 100,
                .names = "summary_{.col}_lag"),
         summary_pge_lag = if_else(is.na(summary_pge_lag), # extrapolate one yr
                                   lead(summary_pge_lag),
                                   summary_pge_lag),
         summary_pge_se_lag = if_else(is.na(summary_pge_se_lag),
                                   lead(summary_pge_se_lag)*1.1,
                                   summary_pge_se_lag),
         pge = pge * 100,
         pge_se = pge_se * 100) %>% 
  ungroup()

# Party data
interleave <- function(data, var) {
  val <- deparse(substitute(var))
  name1.x <- paste0(val, ".x")
  name1.y <- paste0(val, ".y")
  data %>% 
    mutate(!!val := if_else(is.na(.data[[name1.x]]),
                            .data[[name1.y]],
                            .data[[name1.x]])) %>% 
    select(-all_of(name1.x), -all_of(name1.y))
}

by_party <- mp_parties %>% 
  filter(year > 1970) %>%
  mutate(countryname_old = countryname,
         countryname = countrycode::countrycode(countryname,
                                                "country.name",
                                                "country.name",
                                                warn = FALSE)) %>% 
  bind_rows(latam) %>% # not included in mp_parties, no continuity issues
  left_join(weeks,
            by = c("date", "party")) %>% 
  interleave(source) %>% 
  left_join(adams,
            by = c("date", "party")) %>% 
  interleave(source) %>% 
  left_join(party_continuity,
            by = c("countryname", "party")) %>% 
  mutate(party_old = party,
         party = if_else(is.na(party_new), party_old, party_new)) %>% 
  full_join(bind_rows(updates, australia, germany, united_states) %>%
              select(-partyname, -date),
            by = c("party", "countryname", "year")) %>% 
  interleave(source) %>% 
  left_join(qarot,
            by = c("countryname", "year")) %>% 
  left_join(des,
            by = c("countryname", "year")) %>% 
  arrange(countryname, party, year) %>% 
  mutate(parfam = case_when(parfam == 999 ~ NA_real_,
                            is.na(parfam) ~ as.character(party) %>%
                              str_extract("\\d(?=\\d{3}$)") %>%
                              as.numeric() * 10,
                            TRUE ~ parfam),
         pfem = case_when(!is.na(pfem) ~ pfem, # latam
                          is.na(pfem) & !is.na(pfem_a) ~ pfem_a, # updates, etc.
                          is.na(pfem_a) & !is.na(pfem_b) ~ pfem_b, # adams
                          TRUE ~ pfem_c), # weeks
         pfem_lag = lag(pfem),
         leader = case_when(!is.na(femaleleader) ~ femaleleader, # latam
                            is.na(femaleleader) &
                              !is.na(femaleleader_a) ~ femaleleader_a, # updates, etc.
                            is.na(femaleleader) &
                              is.na(femaleleader_a) &
                              !is.na(femaleleader_b) ~ femaleleader_b, # adams
                            TRUE ~ as.numeric(femaleleader_c))) %>%
  group_by(party) %>%
  mutate(seats = if_else(is.na(absseat_a), absseat, absseat_a),
         vote_percent = pervote,
         seat_percent = round((seats/totseats * 100), 1)) %>%
  ungroup() %>%
  left_join(party_quotas,
            by = c("countryname", "party", "year")) %>% 
  mutate(party_quota = if_else(is.na(party_quota), 0, party_quota),
         national_quota = if_else(is.na(defacto_threshold), 0,
                                  defacto_threshold),
         quota = pmax(party_quota, national_quota),
         country = if_else(is.na(country), 
                           round(party/1000),
                           country),
         parfam = if_else(is.na(parfam), 
                          as.character(party) %>% 
                            str_extract("\\d(?=\\d{2}$)") %>%
                            as.numeric() * 10,
                          parfam),
         parfam2 = case_when(between(parfam, 10, 30) ~ "left",
                             (parfam == 40 | parfam == 80) ~ "center",
                             between(parfam, 50, 60) ~ "right",
                             parfam == 70 ~ "extreme right",
                             TRUE ~ "other"),
         parfam3 = if_else(parfam == 10, "green", parfam2),
         leftwing = if_else(parfam2 == "left", 1, 0)) %>% 
  make_dummies("parfam3") %>% 
  group_by(country) %>% 
  fill(list, countryname) %>% 
  ungroup() %>% 
  inner_join(pge_summary,
            by = c("countryname" = "country", "year")) %>%
  distinct(country, year, party, pfem, .keep_all = TRUE) %>% 
  filter(countryname %in% oecd_countries &
           !is.na(pfem) &
           !is.na(summary_pge_lag))

party_pge <- pge %>% 
  group_by(draw) %>% 
  group_split() %>% 
  map(. %>% 
        mutate(pge_lag = lag(pge)*100) %>%
        inner_join(by_party, by = c("country" = "countryname", "year")) %>% 
        group_by(draw, party) %>% 
        mutate(cyear = paste0(country, year),
               cy_code = as.numeric(as.factor(cyear))) %>% 
        ungroup())
      
# Country data
by_country <- qarot %>% 
  left_join(des,
            by = c("countryname", "year")) %>% 
  bind_rows(tibble(countryname = "Slovakia", # not yet independent, but okay
                   year = 1992,
                   women_rep = 15.3,
                   list = 1))  %>% 
  left_join(pge_summary,
            by = c("countryname" = "country", "year")) %>% 
  mutate(country = countryname,
         iso2c = countrycode::countrycode(countryname, 
                                          "country.name",
                                          "iso2c",
                                          warn = FALSE),
         list = case_when(countryname == "Mexico" &
                            year %in% c(1994, 1997, 2021) ~ 1,
                          countryname == "Germany" &
                            year == 2021 ~ 1,
                          countryname == "Canada" &
                            year == 2021 ~ 0,
                          countryname == "United States" &
                            year == 2022 ~ 0,
                          TRUE ~ list),
         women_rep = case_when(countryname == "Germany" &
                                 year == 1983 ~ 9.8, #https://www.bpb.de/themen/gender-diversitaet/frauen-in-deutschland/49418/frauenanteil-im-deutschen-bundestag/
                               countryname == "Germany" &
                                 year == 1987 ~ 15.4,
                               TRUE ~ women_rep),
         women_rep_lag = lag(women_rep),
         women_rep_included = ifelse(!is.na(summary_pge_lag),
                                     women_rep,
                                     NA_real_),
         national_quota = if_else(is.na(defacto_threshold), 0,
                                  defacto_threshold)) %>% 
  filter(countryname %in% oecd_countries) %>%
  left_join(gdppc, by = c("iso2c", "year")) %>% 
  mutate(gdppc = gdppc/10000) %>% 
  arrange(country, year)

country_pge <- pge %>% 
  group_by(draw) %>% 
  group_split() %>% 
  map(. %>% 
        group_by(country) %>% 
        mutate(pge_lag = lag(pge)*100) %>%
        ungroup() %>% 
        inner_join(by_country, by = c("country" = "countryname", "year")))

save(by_country, file = file.path(descrep_path, "data", "by_country.rda"))
save(country_pge, file = file.path(descrep_path, "data", "country_pge.rda"))
save(by_party, file = file.path(descrep_path, "data", "by_party.rda"))
save(party_pge, file = file.path(descrep_path, "data", "party_pge.rda"))
```    

```{r wrts, fig.cap="Women's Descriptive Representation in the OECD \\label{wrts}", fig.height = 9, fig.width = 7.5}
ggplot(data = by_country, aes(x = year, y = women_rep)) +
    theme_bw() +
    theme(legend.position = "none") +
    coord_cartesian(xlim = c(1980, 2022)) +
    labs(x = NULL, y = "Desc Rep") +
    geom_line(linetype = "dotted") +
    geom_line(aes(y = women_rep_included)) +
    facet_wrap(~country, ncol = 6) +
    theme(axis.text.x  = element_text(size = 7,
                                      angle = 90,
                                      vjust = .45,
                                      hjust = .95),
          strip.text.x = element_text(size = 8),
          strip.background = element_rect(fill = "white", colour = "white"),
          plot.title = element_text(size=8))
```
And, to start today, I work with data on quotas and on women in legislatures from the excellent QAROT dataset, by Hughes, Paxton, Clayton, and Zetterberg, which just won the Lijphart/Przeworski/Verba Data Set Award from the Comparative Politics section of the APSA.
Data on whether the electoral system contains at _least_ a party-list _component_ comes from Borman and Golder's Democratic Electoral Systems Around the World.  
And of course PGE for the public's attitudes on gender equality in the public sphere.  
And although women's share of the legislature does fluctuate a little in the course of most legislative terms--people retire and so on--that's not really relevant to these theories, which all focus on what happens in elections.  
So our unit of analysis is the country-election, not the country-year.
We have an unbalanced sample: some countries hold elections more often than others, of course, but we also have longer series of PGE data for some countries than others.
Our scale here runs from light to dark: the darker the country the more observations we have.
We end up with 334 country-elections all together: almost 9 elections per country, on average, but again, as the shading indicates, the sample is unbalanced.
I could probably bump up that number of observations quite a bit by collecting data on women's share of legislatures in the most recent elections--the QAROT data currently ends in 2015--but that's what we've got for now.
[Data added from Parline.]

Party list: open list not effective @Jones1999 (des does not distinguish so maybe unimportant)



### Method {.unnumbered}
Our dataset, then, includes a series of time points from each of the thirty-eight OECD member states.
Pooling these time series and analyzing them together has two long-appreciated advantages [see, e.g., @Stimson1985, 916].
On the one hand, examining changes over time can provide strong evidence of causality for even questions involving concepts like public opinion and women in office that are not subject to manipulation by researchers and so are ill-suited to experimental research.
On the other, examining many countries can provide strong evidence that our conclusions are general and not specific to a particular, possibly exceptional, context.
But certain statistical difficulties associated with these analyses have been long recognized as well [see, again, among others, @Stimson1985].

@Shor2007 demonstrates that two of the difficulties with pooled time series are best addressed using a Bayesian multilevel model including varying intercepts for both space and time.
Such models take into account the distinctive structure of our data as comprised of observations of a particular country in a particular year.
They incorporate the fact that what we see in an observation is influenced by _where_ we are looking.
All observations of Spain or South Korea, for example, may share distinctively Spanish or Korean traits.
If these distinctive traits are unknown and ignored, our model will consistently under- or over-estimate women's descriptive representation for all of our Spanish or Korean observations over time.^[
This problem is a form of _heteroscadisticity_, a violation of the assumption of regression analyses that error variances are equal.]
But these distinctive traits can be modeled by including a varying intercept for each country, a parameter that shifts our prediction of the outcome for all observations from that country by the same amount.
Together, the country parameters avoid the problems caused from those national traits for which we do not have data or otherwise exclude from our analysis.
These models also recognize that what we observe is also influenced by _when_ we are looking; to give an instance, all observations from 2020 may share peculiarities as a result of the COVID-19 pandemic and other events felt around the globe that year.^[
Such contemporaneous correlation violates the regression assumption that, conditional on the model, the errors in our predictions are independent.]
These distinctive temporal characteristics are similarly modeled with a varying intercept for each year.
The year parameters shift our predictions for all observations from a particular year equally to account for whatever 'time shocks' operated on all countries simultaneously at that point in time [@Shor2007, 171-172].

One recurring issue is how to capture _dynamic_ effects, to incorporate such theoretical expectations as that women's success in gaining office now will lead to similar or greater success in the future as female officeholders enjoy the benefits of incumbency and their example inspires more women to run (and more parties to either seek or at least accept their candidacies).

As is often the case, we have a additional concerns.
Further, the 'within-between random effects' specification is employed, meaning each of the time-varying predictors is decomposed into its time-invariant country mean and the difference between each country-year value and this country mean; this specification has been shown superior to fixed effects and other commonly used TSCS specifications for addressing omitted variable bias and endogeneity more generally [see @Bell2015].
The time-varying difference variables capture the short-term effects of the predictors, while the time-invariant country-mean variables reflect their---often different---long-run, "historical" effects [@Bell2015, 137].

The measurement uncertainty in the data for both macrointerest and income inequality was incorporated into the analysis as well [see @Tai2022].


The model was estimated using the `brms` R package [@Burkner2017].

```{r electionsmap, fig.cap="Observed Democratic Elections in the OECD \\label{electionsmap}", fig.height = 6, fig.width = 7.5}
by_country <- rio::import(file.path(descrep_path, "data", "by_country.rda"))
country_pge <- rio::import(file.path(descrep_path, "data", "country_pge.rda"))
by_party <- rio::import(file.path(descrep_path, "data", "by_party.rda"))
party_pge <- rio::import(file.path(descrep_path, "data", "party_pge.rda"))

world1 <- rnaturalearth::ne_countries(scale = "small", returnclass = "sf") %>%
    filter(!admin == "Antarctica")

world_geom <- world1 %>% 
  mutate(country = countrycode::countrycode(admin,
                                            "country.name",
                                            "country.name"),
         oecd = country %in% oecd_countries) %>% 
  filter(!admin == "Antarctica") %>% 
  left_join(by_country %>%
              filter(!is.na(women_rep) & !is.na(summary_pge_lag)) %>% 
              group_by(countryname) %>% 
              count(name = "elections") %>% 
              mutate(elections = ifelse(elections >=18, 18, elections)),
            by = c("country" = "countryname"))

country_map <- ggplot() +
  geom_sf(data = world1) +
  geom_sf(data = world_geom,
          aes(fill = elections)) +
  coord_sf(crs = sf::st_crs("ESRI:53035")) +
  scale_fill_distiller(na.value = "white", 
                       palette = "Greys",
                       direction = 1) +
  theme(legend.position="none")

country_bar <- by_country %>%
  filter(!is.na(women_rep) & !is.na(summary_pge_lag)) %>% 
  group_by(countryname) %>% 
  count(name = "elections") %>% 
  ggplot(aes(forcats::fct_reorder(countryname, elections, .desc = TRUE), 
             elections)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x  = element_text(angle = 90, vjust = .45, hjust = .95),
        axis.title.y = element_text(size = 9),
        plot.title = element_text(hjust = 0.5, size = 11)) +
  ylab("Elections Observed")

country_map +
  country_bar +
  plot_layout(ncol = 1, widths = c(1, 1), heights = c(5, 2))
```

## Country-Elections {.unnumbered}
Our dataset comprises the thirty-eight OECD democracies, each observed in five (Switzerland) to twenty-six (the United States) consecutive elections.
A solid majority of our countries, twenty-six of the thirty-eight, have been observed in at least eight elections, giving us some confidence that we have adequate data to capture not only the differences between the countries in which many women are elected and those with much smaller numbers of women in office but also and perhaps more importantly the dynamics of change over time.
We will start, though, by looking at the raw bivariate data.

```{r wrplot, fig.cap="Public Gender Egalitarianism and Women's Share of Legislative Seats in OECD Democracies \\label{wrplot}", fig.height = 5.5, fig.width = 7.5}
wr_cor <- map(country_pge,
              ~ with(.x, cor(pge_lag, women_rep,
                             use = "pairwise.complete.obs"))) %>% 
  unlist() %>% 
  mean() %>% 
  round(2) %>% 
  sprintf("%.2f", .) %>% 
  paste0("R = ", .)

wr_label <- tibble(summary_pge_lag = .3, women_rep = 48, label = wr_cor)

ggplot(by_country,
       aes(x = summary_pge_lag,
           y = women_rep)) +
  geom_segment(aes(x = summary_p10_lag, xend = summary_p90_lag,
                   y = women_rep, yend = women_rep),
               na.rm = TRUE,
               alpha = .2) +
  geom_text(aes(label = iso2c), size = 2) +
  geom_smooth(method = 'lm', se = FALSE) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=10),
        axis.title = element_text(size=12)) +
  scale_x_continuous(limits=c(min(by_country$summary_p10_lag), 1),
                     breaks=seq(.25, 1, by = .25)) +
  labs(x = TeX("Public Gender Egalitarianism$_{t-1}$"), y = "Women's Share of Legislative Seats") +
  geom_label(data = wr_label, aes(label = label))
```

Each point in Figure&nbsp;\ref{wrplot} represents an election in a particular country, and they are labeled with the countries' two-character iso2c codes.
The figure's x-axis presents the country's Public Gender Egalitarianism score, measured in the year before the election was held.
And because the PGE scores are estimated with uncertainty, each point is shown with a horizontal whiskers.
Its y-axis depicts the extent of women's descriptive representation, measured as the percentage of seats won by women in each election to the lower house of the national legislature.
There is a strong positive relationship between the two.
Taking the uncertainty in the PGE scores into account, the bivariate correlation is `r wr_cor %>% str_extract("\\.\\d{2}")`.
This is promising, but there are many potential explanations for a strong correlation besides the theory that more egalitarian views among the public cause more women to win office.

The first of these is that there may be other factors that influence 

Anyway, so first we basically replicate the scatterplot, but including varying intercepts by country that puts the focus on over-time variation.
The estimate here is that increasing PGE in the year before the election from one standard deviation below its mean to one standard deviation above the mean is associated with an increase in women's share of the legislature of about twelve-and-a-half plus or minus two-and-a-half percentage points.  
Granted, the median change in PGE from one election to the next within a country is only a little more than a sixth of that, yielding an estimate of a typical short-run change in women's descriptive representation of somewhat more than two percentage points.

When we bring in national-level statutory quotas, the focus of much of the literature, the PGE estimate drops a bit, to 10 percentage points, again plus or minus 2-and-a-half.
The estimate for National Quota indicates that a change equivalent to adopting a 25% quota for female candidates when there had been no quota before is associated with women making up an additional six percent of the legislature, give or take a point.

The difference between countries with and without party-list electoral systems is also estimated to be about 6 percent of the legislature, plus-or-minus 4 percent in this case.  Controlling for this difference does nothing to the estimates I just described.

The next two models test for interactions of public gender egalitarianism with quotas, 

and then with party lists.  Both of these estimates are very close to exactly zero.
Looking across these results, I see support for the bottom-up theory as a complement to the top-down processes that we've developed a really good understanding of over the past two-three decades.

```{r wr_b}
if (!file.exists(file.path(descrep_path, "data", "wr_results.rda"))) {
  
  by_country2 <- by_country %>% 
    filter(!is.na(list) & !is.na(summary_pge_lag)) %>% 
    group_by(country) %>% 
    transmute(year,
              women_rep,
              women_rep_lag,
              women_rep_mean = mean(women_rep_lag, na.rm = TRUE),
              women_rep_diff = women_rep_lag - women_rep_mean,
              pge,
              summary_pge_lag,
              pge_mean = mean(summary_pge_lag, na.rm = TRUE),
              pge_mean_se = sqrt(sum(summary_pge_se_lag^2, na.rm = TRUE))/
                  length(summary_pge_lag),
              pge_diff = summary_pge_lag - pge_mean,
              pge_diff_se = sqrt(summary_pge_se_lag^2 + pge_mean_se^2)/2,
              national_quota,
              national_quota_mean = mean(national_quota),
              national_quota_diff = national_quota - national_quota_mean,
              visible_quota = as.numeric(national_quota >= 10),
              list,
              list_mean = mean(list, na.rm = TRUE),
              list_diff = list - list_mean,
              gdppc,
              gdppc_mean = mean(gdppc, na.rm = TRUE),
              gdppc_diff = gdppc - gdppc_mean) %>% 
    ungroup() %>% 
    mutate(time_trend = year - min(year))
  
  bf_wr3 <- bf(women_rep ~ 
                 me(pge_diff, pge_diff_se) +
                 me(pge_mean, pge_mean_se) +
                 national_quota_diff +
                 national_quota_mean + 
                 list_diff +
                 list_mean +
                 (1|c|country) + (1|t|year))
  
  bf_pge3 <- bf(pge ~ 
                  women_rep_diff +
                  women_rep_mean +
                  gdppc_diff +
                  gdppc_mean +
                  list_diff +
                  list_mean +
                  (1|c|country) + (1|t|year))
  
  m3_wr_b <- brm(formula = bf_wr3 + 
                   bf_pge3 + 
                   set_rescor(TRUE),  
                 data = by_country2,
                 backend = "cmdstanr",
                 control=list(adapt_delta = 0.99, 
                              max_treedepth = 15),
                 warmup = 500, 
                 iter = 1000, 
                 chains = 4, 
                 cores = 4,
                 seed = 324)

  bf_wr4 <- bf(diff_women_rep ~ 
                me(diff_pge, diff_pge_se) +
                me(pge_mean, pge_mean_se) +
                national_quota_diff +
                national_quota_mean + 
                list_diff +
                list_mean +
                women_rep_lag +
                (1|c|country) + (1|t|year))
  
  bf_pge <- bf(diff_pge ~ 
                 women_rep_diff +
                 women_rep_mean +
                 gdppc_diff +
                 gdppc_mean +
                 list_diff +
                 list_mean +
                 summary_pge_lag +
                 (1|c|country) + (1|t|year))
  
  m3_wr_b <- brm(formula = bf_wr + 
                   bf_pge + 
                   set_rescor(TRUE),  
                 data = by_country2,
                 backend = "cmdstanr",
                 control=list(adapt_delta = 0.99, 
                              max_treedepth = 15),
                 warmup = 500, 
                 iter = 1000, 
                 chains = 4, 
                 cores = 4,
                 seed = 324)
  
  # m0_data_2sd <- m0_wr_b$data %>% 
  #   select(-`women_rep`,
  #          -country, -year, -ends_with("_se")) %>% 
  #   summarize(across(everything(), by2sd)) %>% 
  #   pivot_longer(everything()) %>% 
  #   transmute(`.variable` = case_when(name == "pge_mean" ~ 
  #                                       "bsp_mepge_meanpge_mean_se",
  #                                     name == "pge_diff" ~
  #                                       "bsp_mepge_diffpge_diff_se",
  #                                     TRUE ~ paste0("b_", name)),
  #             var_names = c("Public Gender Egalitarianism, Mean",
  #                           "Public Gender Egalitarianism, Difference"),
  #             sd2 = value)
  
  m2_data_2sd <- m2_wr_b$data %>% 
    select(-`women_rep`,
           -country, -year, -ends_with("_se")) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    transmute(`.variable` = case_when(name == "pge_mean" ~ 
                                        "bsp_mepge_meanpge_mean_se",
                                      name == "pge_diff" ~
                                        "bsp_mepge_diffpge_diff_se",
                                      TRUE ~ paste0("b_", name)),
              var_names = c("National Quota, Mean",
                            "National Quota, Difference",
                            "Party List, Mean",
                            "Party List, Difference",
                            "Public Gender Egalitarianism, Mean",
                            "Public Gender Egalitarianism, Difference"),
              sd2 = value)
  
  # coef_data0_m0 <- m0_wr_b %>% 
  #   tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
  #   filter(!`.variable`=="b_Intercept") %>% 
  #   left_join(m0_data_2sd, by = join_by(.variable)) %>% 
  #   mutate(std_coef = .value * sd2,
  #          term = factor(var_names, 
  #                        levels = c("National Quota, Mean",
  #                                   "National Quota, Difference")))
  
  coef_data0 <- m2_wr_b %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!`.variable`=="b_Intercept") %>% 
    left_join(m2_data_2sd, by = join_by(.variable))
  
  cy_summary <- m2_wr_b$data %>%
    count(country) %>%
    pull(n) %>%
    summary()
  
  save(m2_data_2sd, coef_data0, cy_summary, 
       file = file.path(descrep_path,
                        "data",
                        "wr_results.rda"))
} else {
  load(file = file.path(descrep_path, "data", "wr_results.rda"))
}
```

```{r resplot, fig.cap="Predicting Women's Parliamentary Representation in OECD Democratic Elections \\label{model}", fig.height = 5.5, fig.width = 7.5}
ordered <- c("Public Gender Egalitarianism, Mean", 
             "Public Gender Egalitarianism, Difference",
             "National Quota, Mean",
             "National Quota, Difference",
             "Party List, Mean", 
             "Party List, Difference") %>% 
  rev()

coef_data <- coef_data0 %>% 
  mutate(std_coef = round(.value * sd2, 1),
         term = factor(var_names, levels = ordered)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9, .95)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m2_data_2sd, ., by = join_by(.variable))

coef_data0 %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered)) %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = c(.8, .9, .95),
                       fill = "grey60") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  coord_cartesian(xlim = c(-10, 20)) +
  theme_light() +
  xlab("Standardized Coefficients") +
  ylab(NULL) +
  plot_annotation(caption = "Notes: Dots indicate posterior means; whiskers, from thickest to thinnest, describe 80%,\n90%, and 95% credible intervals; shading depicts the posterior probability density function.")
```


## Party-Elections {.unnumbered}

```{r partymap, fig.cap="Party-Election Observations in OECD Democracies \\label{partymap}", fig.height = 6, fig.width = 7.5}
parties <- world1 %>% 
  mutate(country = countrycode::countrycode(admin,
                                            "country.name",
                                            "country.name"),
         oecd = country %in% oecd_countries) %>% 
  filter(!admin == "Antarctica") %>% 
  left_join(by_party %>%
              filter(!is.na(pfem) & !is.na(summary_pge_lag)) %>% 
              group_by(countryname) %>% 
              count(name = "party_elections"),
            by = c("country" = "countryname"))

party_map <- ggplot() +
  geom_sf(data = world1) +
  geom_sf(data = parties,
          aes(fill = party_elections)) +
  coord_sf(crs = sf::st_crs("ESRI:53035")) +
  scale_fill_distiller(na.value = "white", 
                       palette = "Greys",
                       direction = 1) +
  theme(legend.position="none")

party_bar <- by_party %>%
  filter(!is.na(pfem) & !is.na(summary_pge_lag)) %>% 
  group_by(countryname) %>% 
  count(name = "party_elections") %>%
  ggplot(aes(forcats::fct_reorder(countryname, party_elections, .desc = TRUE), 
             party_elections)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x  = element_text(angle = 90, vjust = .45, hjust = .95),
        axis.title.y = element_text(size = 9),
        plot.title = element_text(hjust = 0.5, size = 11)) +
  ylab("Party-Elections Observed")

party_map +
  party_bar +
  plot_layout(ncol = 1, widths = c(1, 1), heights = c(5, 2))

```


BUT: I'm betting at least some of you have spotted a disconnect between the theories as I laid them out and this evidence.
The theories were all about things going on at the party level, right?  
*Parties* respond to internal activist pressure and adopt quotas, *parties* react to an increasingly egalitarian public by running more women candidates who can get elected, and so on.
But the unit of analysis here is the country-election. 
We can't really see what going on within the parties, really not at all.

So let's shift to the *party*-election level.
I compiled data on women's share of each party's legislative representation after each election from a couple of great articles that became available FirstView in the APSR just this spring.
Weeks, Meguid, Kittilson, and Coffé 2022 on when Europe's extreme right parties elect more women, and--
Adams, Bracken, Gidron, Horne, O'Brien, and Senk 2022 on the moderating effect of elected women on outparty evaluations.
I recommend both of these pieces to you, btw, if you haven't seen them yet: each of them is a fantastic work with an all-star cast of authors.
Anyway, I raided those articles' replication materials for data, and then Byung-Deuk and I collected a bunch more, especially for the South Korean and the Latin American cases, which neither of those works had included at all.
With party-elections as the unit of analysis, we have almost two thousand observations across our 38 OECD countries.

So, what do we see now? 
Well, as one might have expected, the bivariate relationship is a lot noisier.
For the purposes of presentation, I faded the points in this plot by the parties' share of the legislature: the biggest parties are darkest and the tiniest parties are very light.
But, for the time being at least, I'm following the existing literature and doing nothing with weighting, which means, in effect, weighting each party-election observation equally.
And to be upfront, I feel like these are together a really hard test, because in this literature almost nothing predicts when women will make up a larger share of a party's members of the legislature—sometimes not even national quotas.

```{r pfem_plot}
pfem_cor <- map(party_pge,
                ~ with(.x, cor(pge_lag, pfem,
                               use = "pairwise.complete.obs"))) %>% 
  unlist() %>% 
  mean() %>% 
  round(2) %>% 
  sprintf("%.2f", .) %>% 
  paste0("R = ", .)

pfem_label <- tibble(summary_pge_lag = .3, pfem = 98, label = pfem_cor)

ggplot(by_party,
       aes(x = summary_pge_lag,
           y = pfem)) +
  geom_segment(aes(x = summary_p10_lag, xend = summary_p90_lag,
                   y = pfem, yend = pfem),
               na.rm = TRUE,
               alpha = .1) +
  geom_point(alpha = by_party$seat_percent/100) +
  geom_smooth(method = 'lm', se = FALSE) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=10),
        axis.title = element_text(size=12)) +
  scale_x_continuous(limits=c(0.25, 1),
                     breaks=seq(.25, 1, by = .25)) +
  labs(x = TeX("Public Gender Egalitarianism$_{t-1}$"), y = "Women's Share of Party Legislative Seats") +
  geom_label(data = pfem_label, aes(label = label))

ggsave(file.path(descrep_path, "pfem_plot.jpg"))
```

These are, again, multilevel models, but now they are cross-classified: party-elections are nested in parties and in country-elections which are both nested in countries.
In other words, we have varying intercepts for each party, for each election in a country, and for each country.

Yeah, enough stalling: here's what we get.
A little surprisingly, I think, we get pretty much exactly the same results.
A two-standard-deviation rise in public gender egalitarianism in the year before an election is associated with almost a twelve percentage point increase, plus-or-minus two-and-a-half points, in women's share of a party's seats in the legislature in the bivariate model.

This estimate drops to ten points plus-or-minus two when quotas are added--and now quotas are measured to include voluntary party quotas as well as statutory national quotas.
The quota estimate is seven-and-a-half points plus or minus one--a bit larger than in the models at the country-election level.
I put that down to the better measurement.

```{r pfem_models}
if (!file.exists(file.path(descrep_path, "pfem_results.rda"))) {
  
by_party2 <- by_party %>% 
  left_join(by_country2 %>% 
              select(country,
                     year,
                     starts_with("pge_mean"),
                     starts_with("pge_diff"),
                     list_mean,
                     list_diff) %>% 
              distinct(country, year, .keep_all = TRUE),
            by = c("countryname" = "country", "year")) %>% 
  group_by(party) %>% 
  transmute(country = countryname,
            year,
            cyear = paste0(countryname, year),
            pfem,
            pge_mean, pge_mean_se,
            pge_diff, pge_diff_se,
            national_quota_mean = mean(national_quota, na.rm = TRUE),
            national_quota_diff = national_quota - national_quota_mean,
            party_quota_mean = mean(party_quota, na.rm = TRUE),
            party_quota_diff = party_quota - party_quota_mean,
            list_mean = mean(list, na.rm = TRUE),
            list_diff = list - list_mean,
            pseat_mean = mean(seat_percent, na.rm = TRUE),
            pseat_diff = seat_percent - pseat_mean,
            left,
            green,
            center,
            extreme_right) %>% 
  ungroup()

# m1_pfem_b <- brm(formula = bf(pfem ~ 
#                                 me(pge_mean, pge_mean_se) +
#                                 me(pge_diff, pge_diff_se) +
#                                 national_quota_mean +
#                                 national_quota_diff +
#                                 party_quota_mean +
#                                 party_quota_diff +
#                                 list_mean +
#                                 list_diff +
#                                 (1 | party) + 
#                                 (1 | cyear) +
#                                 (1 | year) +
#                                 (1 | country)),
#                               data = by_party2,
#                               backend = "cmdstanr",
#                               warmup = 500, 
#                               iter = 1000, 
#                               chains = 4, 
#                               cores = 4,
#                               seed = 324)

m2_pfem_b <- brm(formula = bf(pfem ~ 
                                me(pge_mean, pge_mean_se) +
                                me(pge_diff, pge_diff_se) +
                                national_quota_mean +
                                national_quota_diff +
                                party_quota_mean +
                                party_quota_diff +
                                list_mean +
                                list_diff +
                                pseat_mean +
                                pseat_diff +
                                left +
                                green +
                                center +
                                extreme_right +
                                (1 | party) + 
                                (1 | cyear) +
                                (1 | year) +
                                (1 | country)),
                              data = by_party2,
                              backend = "cmdstanr",
                              warmup = 500, 
                              iter = 1000, 
                              chains = 4, 
                              cores = 4,
                              seed = 324)

  m2pf_data_2sd <- m2_pfem_b$data %>% 
    select(-`pfem`,
           -country, -year, -cyear, -party, -ends_with("_se")) %>% 
    summarize(across(everything(), by2sd)) %>% 
    pivot_longer(everything()) %>% 
    transmute(`.variable` = case_when(name == "pge_mean" ~ 
                                        "bsp_mepge_meanpge_mean_se",
                                      name == "pge_diff" ~
                                        "bsp_mepge_diffpge_diff_se",
                                      TRUE ~ paste0("b_", name)),
              var_names = c("National Quota, Country Mean",
                            "National Quota, Difference",
                            "Party Quota, Party Mean",
                            "Party Quota, Difference",
                            "Party List, Country Mean", 
                            "Party List, Difference",
                            "Seat Share, Party Mean",
                            "Seat Share, Difference",
                            "Left Party",
                            "Green Party",
                            "Center Party",
                            "Extreme Right Party",
                            "Public Gender Egalitarianism, Country Mean", 
                            "Public Gender Egalitarianism, Difference"),
              sd2 = value)
  
  coef_data0_m2pf <- m2_pfem_b %>% 
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>% 
    filter(!`.variable`=="b_Intercept") %>% 
    left_join(m2pf_data_2sd, by = join_by(.variable))
  
  cyp_summary <- m2_pfem_b$data %>%
    count(party) %>%
    pull(n) %>%
    summary()

  save(m2pf_data_2sd, coef_data0_m2pf, cyp_summary,
       file = file.path(descrep_path, "pfem_results.rda"))
} else {
  load(file = file.path(descrep_path, "pfem_results.rda"))
}
```
```{r resplot-pfem, fig.cap="Predicting Women's Share of Parties' Legislative Seats in OECD Democracies \\label{resplot-pfem}", fig.height = 5.5, fig.width = 7.5}
ordered_pfem <- c("Public Gender Egalitarianism, Country Mean", 
                  "Public Gender Egalitarianism, Difference",
                  "National Quota, Country Mean",
                  "National Quota, Difference",
                  "Party Quota, Party Mean",
                  "Party Quota, Difference",
                  "Party List, Country Mean", 
                  "Party List, Difference",
                  "Seat Share, Party Mean",
                  "Seat Share, Difference",
                  "Left Party",
                  "Green Party",
                  "Center Party",
                  "Extreme Right Party") %>% 
  rev()

coef_data_m2pf <- coef_data0_m2pf %>% 
  mutate(std_coef = round(.value * sd2, 1),
         term = factor(var_names, levels = ordered)) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9, .95)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m2pf_data_2sd, ., by = join_by(.variable))

coef_data0_m2pf %>% 
  mutate(std_coef = .value * sd2,
         term = factor(var_names, levels = ordered_pfem)) %>% 
  ggplot(aes(y = term, x = std_coef)) +
  ggdist::stat_halfeye(.width = c(.8, .9, .95),
                       fill = "grey60") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  coord_cartesian(xlim = c(-10, 20)) +
  theme_light() +
  xlab("Standardized Coefficients") +
  ylab(NULL) +
  plot_annotation(caption = "Notes: Dots indicate posterior means; whiskers, from thickest to thinnest, describe 80%,\n90%, and 95% credible intervals; shading depicts the posterior probability density function.")
```

Looking across the rest of the models, 

these results don't change much either,

although the point estimate for party lists is a bit smaller and no longer statistically significant at the 5% level.
Intriguingly, the last model, with the interaction between public gender egalitarianism and party lists, that one lends some support to the negative interaction theory. 

That is, that parties under pressure from feminist activists within the party will run more female candidates in party list systems and so elect a statistically significantly larger proportion of women, when the public is not all that egalitarian, than parties in systems without lists.
This difference between parties in list and non-list systems shrinks and loses statistical significance when public gender egalitarianism is greater, until in the most egalitarian settings the difference across electoral systems is estimated to be nearly exactly zero.  
That's a pretty cool result, I think: it shows how party-list electoral systems have presented opportunities for feminist activists to reach their goals even in the face of relatively inhospitable public opinion.

```{r pfem_model_inter, eval=FALSE}
if (!file.exists(file.path(descrep_path, "pfem_results_inter.rda"))) {
  m3_pfem_b <- brm(formula = bf(pfem ~
                                  me(pge_mean, pge_mean_se) +
                                  me(pge_diff, pge_diff_se) +
                                  national_quota_mean +
                                  national_quota_diff +
                                  party_quota_mean +
                                  party_quota_diff +
                                  list_mean +
                                  list_diff +
                                  pseat_mean +
                                  pseat_diff +
                                  left +
                                  green +
                                  center +
                                  extreme_right +
                                  left:me(pge_diff, pge_diff_se) +
                                  green:me(pge_diff, pge_diff_se) +
                                  center:me(pge_diff, pge_diff_se) +
                                  extreme_right:me(pge_diff, pge_diff_se) +
                                  (1 | party) +
                                  (1 | cyear) +
                                  (1 | year) +
                                  (1 | country)),
                   data = by_party2,
                   backend = "cmdstanr",
                   warmup = 500,
                   iter = 1000,
                   chains = 4,
                   cores = 4,
                   seed = 324)

  m3pf_data_2sd <- m3_pfem_b$data %>%
    select(-`pfem`,
           -country, -year, -cyear, -party, -ends_with("_se")) %>%
    summarize(across(everything(), by2sd)) %>%
    pivot_longer(everything()) %>%
    transmute(`.variable` = case_when(name == "pge_mean" ~
                                        "bsp_mepge_meanpge_mean_se",
                                      name == "pge_diff" ~
                                        "bsp_mepge_diffpge_diff_se",
                                      TRUE ~ paste0("b_", name)),
              var_names = c("National Quota, Country Mean",
                            "National Quota, Difference",
                            "Party Quota, Party Mean",
                            "Party Quota, Difference",
                            "Party List, Country Mean",
                            "Party List, Difference",
                            "Seat Share, Party Mean",
                            "Seat Share, Difference",
                            "Left Party",
                            "Green Party",
                            "Center Party",
                            "Extreme Right Party",
                            "Public Gender Egalitarianism, Country Mean",
                            "Public Gender Egalitarianism, Difference"),
              sd2 = value)

  coef_data0_m3pf <- m3_pfem_b %>%
    tidybayes::gather_draws(`bs?p?_.*`, regex = TRUE) %>%
  ggdist::median_qi(std_coef, .width = c(.8, .9, .95)) %>%
  mutate(ci = paste0(round(.lower, 1), " to ", round(.upper, 1))) %>%
  left_join(m3pf_data_2sd, ., by = join_by(.variable))
#   
#   
#   save(m3pf_data_2sd, coef_data0_m3pf, 
#        file = file.path(descrep_path,
#                         "pfem_results_inter.rda"))
# } else {
#   load(file = file.path(descrep_path, "pfem_results_inter.rda"))
# }
# 
# ordered_pi <- c("Public Gender Egalitarianism, Country Mean", 
#                 bquote(Public~Gender~Egalitarianism[t-1],~Country~Difference),
#                 "Quota, Party Mean",
#                 "Quota, Difference",
#                 "Party List, Country Mean", 
#                 "Party List, Difference",
#                 "Seat Share, Party Mean",
#                 "Seat Share, Difference",
#                 "Left Party",
#                 "Green Party",
#                 "Center Party",
#                 "Extreme Right Party",
#                 bquote(PGE[t-1] %*% Left),
#                 bquote(PGE[t-1] %*% Green),
#                 bquote(PGE[t-1] %*% Center),
#                 bquote(PGE[t-1] %*% Extreme~Right)) %>% 
#   rev()
```



```{r leader, eval=FALSE}
m1_leader <- party_pge %>%
  map(~ glmer(leader ~ pge_lag_by2sd +
               (1 | party ) + (1 | cyear) + (1 | country),
              family = "binomial",
             data = .x)) %>% 
  sim_and_tidy()

m2_leader <- party_pge %>%
  map(~ glmer(leader ~ pge_lag_by2sd +
               quota +
               (1 | party ) + (1 | cyear) + (1 | country),
              family = "binomial",
             data = .x)) %>% 
  sim_and_tidy()

m3_leader <- party_pge %>%
  map(~ glmer(leader ~ pge_lag_by2sd +
               quota +
               list +
               (1 | party ) + (1 | cyear) + (1 | country),
              family = "binomial",
             data = .x)) %>% 
  sim_and_tidy()
```


```{r pfem_plot_by_partyfam, eval=FALSE}
pfem_by_party_cor <- map(c("green", "left",
                           "center", "right",
                           "extreme right", "other"), function(pf3) {
  map(party_pge,
      ~ with(.x %>% 
               filter(parfam3 == pf3),
             cor(pge_lag, pfem,
                 use = "pairwise.complete.obs"))) %>% 
    unlist() %>% 
    mean() %>% 
    round(2) %>% 
    sprintf("%.2f", .) %>% 
    paste0("R = ", .)
})

pfem_by_party_label <- tibble(summary_pge_lag = .3,
                              pfem = c(98, 96, 94, 92, 90, 88),
                              label = pfem_by_party_cor,
                              parfam3 = c("green", "left", "center",
                                          "right", "extreme right", "other"))

pfem_by_party_plot <- ggplot(by_party,
                             aes(x = summary_pge_lag,
                                 y = pfem,
                                 color = parfam3)) +
  geom_segment(aes(x = summary_p10_lag, xend = summary_p90_lag,
                   y = pfem, yend = pfem,
                   color = parfam2),
               na.rm = TRUE,
               alpha = .2) +
  geom_point() +
  geom_smooth(method = 'lm', se = FALSE) +
  theme_bw() +
  # scale_color_manual(values=c("black",
  #                             "#64A12D", # Grüen Green
  #                             "#009EE0", # AfD Blue
  #                             "#EB001F", # SPD Red
  #                             "#2D3D95",  # Swedish Moderates Blue
  #                             "gray50")) +
    scale_color_manual(values=c("center" = "black",
                              "green" = "chartreuse", 
                              "extreme right" = "#009EE0", # AfD Blue
                              "left" = "darkred", 
                              "right" = "blue4",
                              "other" = "gray50")) +
  theme(legend.position="none",
        axis.text  = element_text(size=10),
        axis.title = element_text(size=12)) +
  scale_x_continuous(limits=c(0.25, 1),
                     breaks=seq(.25, 1, by = .25)) +
  labs(x = TeX("Public Gender Egalitarianism$_{t-1}$"),
       y = "Women's Share of Party Legislative Seats") +
  geom_label(data = pfem_by_party_label, aes(label = label))

ggsave(here::here("paper",
                  "descriptive_representation",
                  "pfem_by_party_plot.jpg"))

pfem_by_party_plot
```

All right, it's time to wrap up.
To review the findings, we found plenty of support for the well established top-down theory that feminist activists working within political parties are a major force for getting women elected.
Gender quotas and party lists, the key institutional features associated with this argument, are robustly associated with more female candidates winning office at both the country and the party level.
But there's strong support, too, for the bottom-up theory, which complicates the purest versions of the top-down theory: the activists working hard within parties to build space for women are not the entire story.
More women gain office when the public's views on the role of women in the workplace and in politics are more egalitarian.
The two are complements.
It does not appear, though, that they interact in the sense that parties do not seem to respond to greater public demand for gender equality by making their gender quotas more effective or placing women in better spots on their party list.
These sorts of positive interactions just are not supported in the analyses I have shown you today.
Conversely, in fact, our findings indicate that electoral systems with a party-list component seem to better position activists to get more candidates on the ballot and in office than electoral systems without this feature do *when the public's views are relatively _in_egalitarian*.
Non-party-list systems elect similar numbers of women only when public gender egalitarianism is high.

So that's where things stand.
The attitudes of the public, which were, back in the twentieth century and the early years of this one, a big part of how scholars tried to explain how women win office, these attitudes have lately been pretty neglected.
And I think that is down to measurement--until now, it's been easier to measure the other sorts of things thought to enter party elites' calculations.
But the PGE database gives us a new lens for examining these questions and others--for our book manuscript, we're also working on the question of whether public opinion, independent of women's descriptive representation, directly shapes the adoption of policies like family leave and efforts to combat violence against women.
I mean, it might: even male legislators will want to satisfy their constituents who want gender egalitarian policies, and they may be more likely to even be more egalitarian themselves.
So we'll see, though it really could be that if there's a relationship it all works through women legislators.
But that's future work.
Right now, we conclude that taking public gender egalitarianism into account is a valuable complement to top-down elite-led theories of how women gain descriptive representation.
